Index: workspace/ui/src/main/java/com/ditto/workspace/ui/WorkspaceTabFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.ditto.workspace.ui\r\n\r\nimport android.Manifest\r\nimport android.annotation.SuppressLint\r\nimport android.bluetooth.BluetoothAdapter\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.content.pm.PackageManager\r\nimport android.content.res.Configuration\r\nimport android.graphics.*\r\nimport android.graphics.drawable.VectorDrawable\r\nimport android.os.Build\r\nimport android.os.Bundle\r\nimport android.provider.Settings\r\nimport android.util.DisplayMetrics\r\nimport android.util.Log\r\nimport android.view.*\r\nimport android.view.animation.OvershootInterpolator\r\nimport android.view.animation.ScaleAnimation\r\nimport android.widget.TextView\r\nimport androidx.activity.OnBackPressedCallback\r\nimport androidx.annotation.NonNull\r\nimport androidx.annotation.Nullable\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.appcompat.app.AlertDialog\r\nimport androidx.core.content.ContextCompat\r\nimport androidx.core.content.res.ResourcesCompat\r\nimport androidx.core.os.bundleOf\r\nimport androidx.navigation.fragment.findNavController\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.bumptech.glide.Glide\r\nimport com.bumptech.glide.load.engine.DiskCacheStrategy\r\nimport com.bumptech.glide.request.target.Target.SIZE_ORIGINAL\r\nimport com.ditto.connectivity.ConnectivityActivity\r\nimport com.ditto.logger.Logger\r\nimport com.ditto.logger.LoggerFactory\r\nimport com.ditto.workspace.domain.model.DragData\r\nimport com.ditto.workspace.domain.model.PatternsData\r\nimport com.ditto.workspace.domain.model.SpliceImages\r\nimport com.ditto.workspace.domain.model.WorkspaceItems\r\nimport com.ditto.workspace.ui.adapter.PatternPiecesAdapter\r\nimport com.ditto.workspace.ui.databinding.WorkspaceTabItemBinding\r\nimport com.ditto.workspace.ui.util.*\r\nimport com.joann.fabrictracetransform.transform.TransformErrorCode\r\nimport com.joann.fabrictracetransform.transform.performTransform\r\nimport core.appstate.AppState\r\nimport core.ui.BaseFragment\r\nimport core.ui.ViewModelDelegate\r\nimport core.ui.common.DoubleClickListener\r\nimport core.ui.common.Utility\r\nimport core.ui.common.Utility.Companion.getAlertDialogue\r\nimport core.ui.common.Utility.Companion.getBitmap\r\nimport core.ui.common.Utility.Companion.getDrawableFromString\r\nimport io.reactivex.Observable\r\nimport io.reactivex.android.schedulers.AndroidSchedulers\r\nimport io.reactivex.rxkotlin.plusAssign\r\nimport io.reactivex.rxkotlin.subscribeBy\r\nimport io.reactivex.schedulers.Schedulers\r\nimport kotlinx.android.synthetic.main.workspace_layout.*\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.GlobalScope\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.withContext\r\nimport java.io.*\r\nimport java.net.Socket\r\nimport java.text.SimpleDateFormat\r\nimport java.util.*\r\nimport javax.inject.Inject\r\n\r\n\r\n@RequiresApi(Build.VERSION_CODES.KITKAT)\r\nclass WorkspaceTabFragment : BaseFragment(), View.OnDragListener, DraggableListener,\r\n    Utility.CallbackDialogListener, com.ditto.workspace.ui.util.Utility.CallbackDialogListener,\r\n    Utility.CustomCallbackDialogListener {\r\n\r\n    @Inject\r\n    lateinit var loggerFactory: LoggerFactory\r\n    lateinit var backpressCall: OnBackPressedCallback\r\n    private var cutCount = 0\r\n    private var adapter: PatternPiecesAdapter? = null\r\n\r\n    val logger: Logger by lazy {\r\n        loggerFactory.create(WorkspaceTabFragment::class.java.simpleName)\r\n    }\r\n\r\n    private val viewModel: WorkspaceViewModel by ViewModelDelegate()\r\n    private var mWorkspaceEditor: WorkspaceEditor? = null\r\n    lateinit var binding: WorkspaceTabItemBinding\r\n    private var matchedPattern: PatternsData? = null\r\n    private var isCompleted: Boolean? = null\r\n    private lateinit var alert: AlertDialog\r\n    private lateinit var outputDirectory: File\r\n    private val FILENAME_FORMAT = \"yyyy-MM-dd-HH-mm-ss-SSS\"\r\n\r\n    override fun onCreateView(\r\n        @NonNull inflater: LayoutInflater,\r\n        @Nullable container: ViewGroup?,\r\n        @Nullable savedInstanceState: Bundle?\r\n    ): View? {\r\n        if (!::binding.isInitialized) {\r\n            binding = WorkspaceTabItemBinding.inflate(\r\n                inflater\r\n            )\r\n        }\r\n        return binding.root\r\n    }\r\n\r\n    @SuppressLint(\"FragmentBackPressedCallback\")\r\n    override fun onActivityCreated(@Nullable savedInstanceState: Bundle?) {\r\n        super.onActivityCreated(savedInstanceState)\r\n        arguments?.getInt(PATTERN_ID)?.let { viewModel.patternId.set(it) }\r\n        arguments?.getString(PATTERN_CATEGORY)?.let { viewModel.tabCategory = (it) }\r\n        if (AppState.getIsLogged()) {\r\n            viewModel.fetchWorkspaceSettingData()\r\n        }\r\n        if (viewModel.data.value == null) {\r\n            viewModel.fetchWorkspaceData()\r\n            viewModel.fetchWorkspaceDataFromAPI()\r\n            setPatternPiecesAdapter()\r\n            setUIEvents()\r\n            enableMirror(false)\r\n            if (mWorkspaceEditor?.views?.any() ?: true) {\r\n                enableSelectAll(false)\r\n                enableClear(false)\r\n            }\r\n        }\r\n        setConnectButton()\r\n        setupWorkspace()\r\n        binding.viewModel = viewModel\r\n        binding.lifecycleOwner = viewLifecycleOwner\r\n        binding.recyclerViewPieces.setOnDragListener(this)\r\n        //binding.imageCutBin.setOnDragListener(this)\r\n        binding.cutbinLay?.setOnDragListener(this)\r\n        binding.seekbarStatus.isEnabled = false\r\n        binding.includeWorkspacearea?.layoutWorkspace?.setOnDragListener(this)\r\n        binding.includeWorkspacearea?.layoutWorkspace?.let { mWorkspaceEditor?.selectAllDrag(it) }\r\n        backpressCall =\r\n            object : OnBackPressedCallback(\r\n                true\r\n            ) {\r\n                override fun handleOnBackPressed() {\r\n                    if (baseViewModel.isSaveExitButtonClicked.get()) {\r\n                        viewModel.disposable.clear()\r\n                        isEnabled = false\r\n                        //findNavController().popBackStack(R.id.patternDescriptionFragment, true)\r\n                        activity?.onBackPressed()\r\n                        baseViewModel.isSaveExitButtonClicked.set(false)\r\n                    } else {\r\n                        showSaveAndExitPopup()\r\n//                        moveToLibrary()\r\n                    }\r\n                }\r\n            }\r\n        requireActivity().onBackPressedDispatcher.addCallback(this, backpressCall)\r\n        outputDirectory = Utility.getOutputDirectory(requireContext())\r\n        binding.root?.let { setupKeyboardListener(it) }\r\n        binding.imageSelvageHorizontal.setOnClickListener(object : DoubleClickListener(),\r\n            View.OnClickListener {\r\n            override fun onDoubleClick(v: View) {\r\n                showPinchZoomPopup(requireContext(), viewModel.referenceImage.get(), true)\r\n            }\r\n        })\r\n    }\r\n\r\n    private fun setUIEvents() {\r\n        viewModel.disposable += viewModel.events\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .subscribe {\r\n                handleEvent(it)\r\n            }\r\n    }\r\n\r\n    private fun setupWorkspace() {\r\n        if (mWorkspaceEditor == null) {\r\n            mWorkspaceEditor = context?.let {\r\n                binding.includeWorkspacearea?.layoutWorkspace?.let { it1 ->\r\n                    WorkspaceEditor.Builder(\r\n                        it,\r\n                        it1\r\n                    ).build()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun setPatternPiecesAdapter() {\r\n        adapter = PatternPiecesAdapter()\r\n        binding.recyclerViewPieces.adapter = adapter\r\n        adapter?.viewModel = viewModel\r\n    }\r\n\r\n    private fun refreshPatternPiecesAdapter() {\r\n        com.ditto.workspace.ui.util.Utility.progressCount.set(0)\r\n        binding.recyclerViewPieces.adapter?.notifyDataSetChanged()\r\n    }\r\n\r\n    private fun startProjecting() {\r\n        logger.d(\"Trace Entered Projection\")\r\n        //com.ditto.base.core.ui.common.Utility.showSnackBar(\"Projecting\",binding.workspaceRoot)  // Checking projection scenario without connecting.\r\n        if (mWorkspaceEditor?.views?.size ?: 0 < 1) {\r\n            GlobalScope.launch {\r\n                Utility.sendDittoImage(\r\n                    requireContext(),\r\n                    \"solid_black\"\r\n                )\r\n            }\r\n        } else {\r\n            if (baseViewModel.activeSocketConnection.get()) {\r\n                if (baseViewModel.isProjecting.get()) {\r\n                    showWaitingMessage(resources.getString(R.string.projection_area_progress))\r\n                } else {\r\n                    showWaitingMessage(resources.getString(R.string.projecting_messsage))\r\n                    GlobalScope.launch {\r\n                        if (viewModel.isProjectionRequest.get() && !baseViewModel.isProjecting.get()) {\r\n                            viewModel.isFromQuickCheck.set(false)\r\n                            transform(\r\n                                getVirtualWorkspace(), false\r\n                            )     // ----------plexar library integration---------------------//\r\n                            //projectWorkspaceImage(getVirtualWorkspace(),false false)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun setupKeyboardListener(view: View?) {\r\n        view?.viewTreeObserver?.addOnGlobalLayoutListener {\r\n            val r = Rect()\r\n            view.getWindowVisibleDisplayFrame(r)\r\n            if (Math.abs(view.rootView.height - (r.bottom - r.top)) > (view.rootView.height / 2)) { // if more than 100 pixels, its probably a keyboard...\r\n                if (isTablet(requireContext())) {\r\n                    com.ditto.workspace.ui.util.Utility.changeAlertPsoition(\r\n                        0,\r\n                        view.rootView.height / 2\r\n                    )\r\n\r\n                } else {\r\n                    com.ditto.workspace.ui.util.Utility.changeAlertPsoition(\r\n                        1,\r\n                        view.rootView.height / 2\r\n                    )\r\n                }\r\n            } else {\r\n                com.ditto.workspace.ui.util.Utility.changeAlertPsoition(2, view.rootView.height / 2)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun isTablet(context: Context?): Boolean {\r\n        val xlarge = context?.getResources()\r\n            ?.getConfiguration()?.screenLayout?.and(Configuration.SCREENLAYOUT_SIZE_MASK) ?: 0 == 4\r\n        val large = context?.getResources()\r\n            ?.getConfiguration()?.screenLayout?.and(Configuration.SCREENLAYOUT_SIZE_MASK) ?: 0 == Configuration.SCREENLAYOUT_SIZE_LARGE\r\n        return xlarge || large\r\n    }\r\n\r\n    private fun showWaitingMessage(message: String) {\r\n        try {\r\n            Utility.showSnackBar(message, binding?.workspaceRoot)\r\n        } catch (e: java.lang.Exception) {\r\n            logger.d(\"Error : \" + e.message)\r\n        }\r\n    }\r\n\r\n    private fun disableInchTabs() {\r\n        viewModel.clickedSplice.set(false)\r\n        binding.txtSizeSplice.isEnabled = false\r\n        viewModel.enableSplice.set(false)\r\n        binding.txtSize45.isEnabled = false\r\n        viewModel.enableSize45.set(false)\r\n        binding.txtSize60.isEnabled = false\r\n        viewModel.enableSize60.set(false)\r\n    }\r\n\r\n    private fun disableInchTabs(view: TextView) {\r\n        view.isEnabled = false\r\n        viewModel\r\n        view.setBackgroundResource(R.drawable.rounded_light_bg)\r\n        view.setTextColor(\r\n            ContextCompat.getColor(\r\n                requireContext(),\r\n                R.color.default_splice\r\n            )\r\n        )\r\n    }\r\n\r\n    private fun saveBitmap(bitmap: Bitmap) {\r\n        val photoFile = File(\r\n            outputDirectory, \"TRACE_IMAGE_\" +\r\n                    SimpleDateFormat(\r\n                        FILENAME_FORMAT, Locale.US\r\n                    ).format(System.currentTimeMillis()) + \".jpg\"\r\n        )\r\n        try {\r\n            val stream: OutputStream = FileOutputStream(photoFile)\r\n            bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)\r\n            stream.flush()\r\n            stream.close()\r\n            Utility.galleryAddPic(requireContext(), photoFile.absolutePath)\r\n        } catch (e: IOException) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    private fun transform(bitmap: Bitmap, isProjectingSample: Boolean) {\r\n        logger.d(\"TRACE_ Projection :Transform start \" + Calendar.getInstance().timeInMillis)\r\n        viewModel.isStartedProjection.set(true)\r\n        viewModel.isProjectionRequest.set(false)\r\n        baseViewModel.isProjecting.set(true)\r\n        saveBitmap(bitmap)\r\n        viewModel.disposable += Observable.fromCallable {\r\n            performTransform(bitmap, context?.applicationContext, null, true)\r\n        }\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .subscribeBy { handleResult(it, isProjectingSample) }\r\n\r\n    }\r\n\r\n    private fun showProgress(toShow: Boolean) {\r\n        bottomNavViewModel.showProgress.set(toShow)\r\n    }\r\n\r\n    private fun handleResult(\r\n        result: Pair<TransformErrorCode, Bitmap>,\r\n        isProjectingSample: Boolean\r\n    ) {\r\n        logger.d(\"quick check Transform - ${result.second.width} * ${result.second.height}\")\r\n        //alert.dismiss()\r\n        when (result.first) {\r\n            TransformErrorCode.Success -> {\r\n                logger.d(\"TRACE_ Projection :TransformErrorCode.Success \" + Calendar.getInstance().timeInMillis)\r\n                saveBitmap(result.second)\r\n                logger.d(\"TRACE_ Transformed bitmap width \" + result.second.width)\r\n                logger.d(\"TRACE_ Transformed bitmap height \" + result.second.height)\r\n                GlobalScope.launch {\r\n                    projectWorkspaceImage(\r\n                        result.second,\r\n                        viewModel.isFromQuickCheck.get(),\r\n                        isProjectingSample\r\n                    )\r\n                }\r\n            }\r\n            TransformErrorCode.InvalidImageFormat, TransformErrorCode.RetakeImage -> {\r\n                // show alert?\r\n            }\r\n            TransformErrorCode.AdditionalImageNeeded -> {\r\n                // show alert?\r\n            }\r\n            TransformErrorCode.FailToSetTransformParms, TransformErrorCode.MissingTransformParmsFile -> {\r\n                // what to do?\r\n            }\r\n        }\r\n    }\r\n\r\n    private suspend fun projectWorkspaceImage(\r\n        bitmap: Bitmap,\r\n        isQuickCheck: Boolean,\r\n        isProjectingSample: Boolean\r\n    ) {\r\n        withContext(Dispatchers.IO) {\r\n            logger.d(\"TRACE_ Projection :projectWorkspaceImage Start \" + Calendar.getInstance().timeInMillis)\r\n            var clientSocket: Socket? = null\r\n            try {\r\n                viewModel.isStartedProjection.set(true)\r\n                viewModel.isProjectionRequest.set(false)\r\n                baseViewModel.isProjecting.set(true)\r\n                val transformedBitmap =\r\n                    Bitmap.createBitmap(bitmap.width, bitmap.height, bitmap.config)\r\n                val canvas = Canvas(transformedBitmap)\r\n                canvas.drawColor(Color.BLACK)\r\n                canvas.drawBitmap(bitmap, 0F, 0F, null)\r\n                clientSocket = Socket(\r\n                    core.network.NetworkUtility.nsdSericeHostName,\r\n                    core.network.NetworkUtility.nsdSericePortName\r\n                )\r\n                val workspaceStream = ByteArrayOutputStream()\r\n                transformedBitmap.compress(Bitmap.CompressFormat.PNG, 0, workspaceStream)\r\n                val bitmapdata = workspaceStream.toByteArray()\r\n                transformedBitmap.recycle()\r\n                if (clientSocket.isConnected) {\r\n                    baseViewModel.activeSocketConnection.set(true)\r\n                    var dataOutputStream: DataOutputStream =\r\n                        DataOutputStream(clientSocket.getOutputStream())\r\n                    dataOutputStream.write(bitmapdata)\r\n                    dataOutputStream.close()\r\n                    baseViewModel.isProjecting.set(false)\r\n                    withContext(Dispatchers.Main) {\r\n                        logger.d(\"TRACE_ Projection :projectWorkspaceImage Finish \" + Calendar.getInstance().timeInMillis)\r\n                        showProgress(false)\r\n                        if (isProjectingSample) {\r\n                            navigateToCalibration()\r\n                        }\r\n                        if (isQuickCheck) {\r\n                            showQuickCheckDialog()\r\n                        }\r\n                    }\r\n                } else {\r\n                    baseViewModel.activeSocketConnection.set(false)\r\n                    baseViewModel.isProjecting.set(false)\r\n                    viewModel.isProjectionRequest.set(false)\r\n                    logger.d(\"Socket Connection lost!!\")\r\n                    withContext(Dispatchers.Main) {\r\n                        logger.d(\"TRACE_ Projection :projectWorkspaceImage Finish \" + Calendar.getInstance().timeInMillis)\r\n                        showProgress(false)\r\n                        /*Toast.makeText(\r\n                            requireContext(),\r\n                            resources.getString(R.string.socketfailed),\r\n                            Toast.LENGTH_SHORT\r\n                        ).show()*/\r\n                        showFailurePopup()\r\n                    }\r\n                }\r\n            } catch (e: Exception) {\r\n                baseViewModel.activeSocketConnection.set(false)\r\n                baseViewModel.isProjecting.set(false)\r\n                viewModel.isProjectionRequest.set(false)\r\n                logger.d(\"Exception \" + e.message)\r\n                withContext(Dispatchers.Main) {\r\n                    logger.d(\"TRACE_ Projection :projectWorkspaceImage Finish \" + Calendar.getInstance().timeInMillis)\r\n                    showProgress(false)\r\n                    showFailurePopup()\r\n                }\r\n            } finally {\r\n                clientSocket?.close()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun setSelvageImage() {\r\n        if (viewModel.clickedSplice.get()) {\r\n            val splicePiece = getSplicePiece(\r\n                viewModel.workspacedata?.currentSplicedPieceRow ?: 0,\r\n                viewModel.workspacedata?.currentSplicedPieceColumn ?: 0,\r\n                viewModel.workspacedata?.splicedImages\r\n            )\r\n            // Setting splice reference layout\r\n            showSpliceReference(splicePiece)\r\n            return\r\n        }\r\n        if (viewModel.data.value?.selvages?.filter { it.tabCategory == getString(R.string.garments) }?.size ?: 0 > 0 &&\r\n            viewModel.tabCategory == getString(R.string.garments)\r\n        ) {\r\n            val garments =\r\n                viewModel.data.value?.selvages?.filter {\r\n                    it.tabCategory == getString(\r\n                        R.string.garments\r\n                    )\r\n                }\r\n            if (garments?.size == 2) {\r\n                binding.txtSize45.isEnabled = true\r\n                binding.txtSize60.isEnabled = true\r\n                viewModel.enableSize45.set(true)\r\n                viewModel.enableSize60.set(true)\r\n                if (!viewModel.clickedSize45.get() && !viewModel.clickedSize60.get()) {\r\n                    viewModel.clickedSize45.set(true)\r\n                    viewModel.clickedSize60.set(false)\r\n                }\r\n                if (viewModel.clickedSize45.get()) {\r\n                    val selvage = garments.filter { it.fabricLength == \"45\" }[0]\r\n                    selvage.imagePath.let {\r\n                        binding.imageSelvageHorizontal.setImageDrawable(\r\n                            getDrawableFromString(context, it)\r\n                        )\r\n                    }\r\n                    viewModel.clickedSize45.set(true)\r\n                    viewModel.clickedSize60.set(false)\r\n                    viewModel.referenceImage.set(selvage.imagePath)\r\n                }\r\n                if (viewModel.clickedSize60.get()) {\r\n                    val selvage = garments.filter { it.fabricLength == \"60\" }[0]\r\n                    selvage.imagePath.let {\r\n                        binding.imageSelvageHorizontal.setImageDrawable(\r\n                            getDrawableFromString(context, it)\r\n                        )\r\n                    }\r\n                    viewModel.clickedSize45.set(false)\r\n                    viewModel.clickedSize60.set(true)\r\n                    viewModel.referenceImage.set(selvage.imagePath)\r\n                }\r\n            } else {\r\n                if (garments?.get(0)!!.fabricLength == \"45\") {\r\n                    binding.txtSize45.isEnabled = true\r\n                    viewModel.enableSize45.set(true)\r\n                    viewModel.clickedSize45.set(true)\r\n                } else if (garments[0].fabricLength == \"60\") {\r\n                    binding.txtSize60.isEnabled = true\r\n                    viewModel.enableSize60.set(true)\r\n                    viewModel.clickedSize60.set(true)\r\n                }\r\n                garments[0].imagePath.let {\r\n                    binding.imageSelvageHorizontal.setImageDrawable(\r\n                        getDrawableFromString(context, it)\r\n                    )\r\n                }\r\n                viewModel.referenceImage.set(garments[0].imagePath)\r\n            }\r\n        }\r\n\r\n        if (viewModel.data.value?.selvages?.filter { it.tabCategory == getString(R.string.lining) }\r\n                ?.isNotEmpty() == true &&\r\n            viewModel.tabCategory == getString(R.string.lining)\r\n        ) {\r\n            val lining =\r\n                viewModel.data.value?.selvages?.filter {\r\n                    it.tabCategory == getString(\r\n                        R.string.lining\r\n                    )\r\n                }\r\n            lining?.get(0)?.imagePath?.let {\r\n                binding.imageSelvageHorizontal.setImageDrawable(\r\n                    getDrawableFromString(context, it)\r\n                )\r\n            }\r\n            binding.txtSize45.isEnabled = lining?.get(0)?.fabricLength == \"45\"\r\n            binding.txtSize60.isEnabled = lining?.get(0)?.fabricLength == \"60\"\r\n            viewModel.enableSize45.set(lining?.get(0)?.fabricLength == \"45\")\r\n            viewModel.enableSize60.set(lining?.get(0)?.fabricLength == \"60\")\r\n\r\n            if (lining?.get(0)?.fabricLength == \"45\") {\r\n                viewModel.clickedSize45.set(true)\r\n            } else {\r\n                viewModel.clickedSize60.set(true)\r\n            }\r\n            viewModel.referenceImage.set(lining?.get(0)?.imagePath)\r\n        }\r\n\r\n        if (viewModel.data.value?.selvages?.filter { it.tabCategory == getString(R.string.interfacing) }\r\n                ?.isNotEmpty() == true &&\r\n            viewModel.tabCategory == getString(R.string.interfacing)\r\n        ) {\r\n            val interfacing =\r\n                viewModel.data.value?.selvages?.filter {\r\n                    it.tabCategory == getString(\r\n                        R.string.interfacing\r\n                    )\r\n                }\r\n            interfacing?.get(0)?.imagePath?.let {\r\n                binding.imageSelvageHorizontal.setImageDrawable(\r\n                    getDrawableFromString(context, it)\r\n                )\r\n            }\r\n            binding.txtSize45.isEnabled = interfacing?.get(0)?.fabricLength == \"45\"\r\n            binding.txtSize60.isEnabled = interfacing?.get(0)?.fabricLength == \"60\"\r\n            viewModel.enableSize45.set(interfacing?.get(0)?.fabricLength == \"45\")\r\n            viewModel.enableSize60.set(interfacing?.get(0)?.fabricLength == \"60\")\r\n\r\n            if (interfacing?.get(0)?.fabricLength == \"45\") {\r\n                viewModel.clickedSize45.set(true)\r\n            } else {\r\n                viewModel.clickedSize60.set(true)\r\n            }\r\n\r\n            viewModel.referenceImage.set(interfacing?.get(0)?.imagePath)\r\n        }\r\n    }\r\n\r\n    fun clearWorkspace() {\r\n        disableInchTabs()\r\n        setSelvageImage()\r\n        viewModel.showDoubleTouchToZoom.set(false)\r\n        binding.invalidateAll()\r\n\r\n        if (com.ditto.workspace.ui.util.Utility.progressCount.get() == 0) {\r\n            viewModel.clickReset()\r\n        }\r\n//        binding.includeWorkspacearea?.layoutWorkspaceBackground?.setBackgroundResource(\r\n//            R.drawable.ic_workspace_new\r\n//        )\r\n//        binding.includeWorkspacearea?.layoutSelectAllMask?.visibility = View.GONE\r\n        viewModel.selectAllText.set(getString(R.string.select_all))\r\n        enableMirror(false)\r\n        enableSelectAll(false)\r\n        enableClear(false)\r\n        mWorkspaceEditor?.clearAllViews()\r\n        viewModel.workspacedata = null\r\n        viewModel.spliced_pices_visibility.set(false)\r\n        viewModel.clicked_spliced_second_pieces.set(viewModel.spliced_pices.get() == 2) // setting true only when screen 2 else false by default\r\n        onUpdateProgressCount()\r\n        viewModel.isSpliceBottomVisible.set(false)\r\n        viewModel.isSpliceTopVisible.set(false)\r\n        viewModel.isSpliceLeftVisible.set(false)\r\n        viewModel.isSpliceRightVisible.set(false)\r\n    }\r\n\r\n    private fun calculateScrollButtonVisibility() {\r\n        val layoutManager: LinearLayoutManager =\r\n            binding.recyclerViewPieces.layoutManager as LinearLayoutManager\r\n        viewModel.firstItemVisible.set(layoutManager.findFirstCompletelyVisibleItemPosition())\r\n        viewModel.lastItemVisible.set(layoutManager.findLastCompletelyVisibleItemPosition())\r\n        binding.recyclerViewPieces.adapter?.itemCount?.minus(1)\r\n            ?.let { viewModel.totalItemCount.set(it) }\r\n        viewModel.isScrollButtonVisible.set(!((viewModel.firstItemVisible.get() == 0) && (viewModel.lastItemVisible.get() == viewModel.totalItemCount.get())))\r\n        binding.recyclerViewPieces.addOnScrollListener(object :\r\n            RecyclerView.OnScrollListener() {\r\n            override fun onScrolled(\r\n                recyclerView: RecyclerView,\r\n                dx: Int,\r\n                dy: Int\r\n            ) {\r\n                super.onScrolled(recyclerView, dx, dy)\r\n                viewModel.isFirstItemVisible.set(false)\r\n                viewModel.isLastItemVisible.set(false)\r\n                if (layoutManager.findFirstCompletelyVisibleItemPosition() == 0) {\r\n                    viewModel.isFirstItemVisible.set(true)\r\n                    return\r\n                }\r\n                val shouldPullUpRefresh =\r\n                    layoutManager.findLastCompletelyVisibleItemPosition() == viewModel.totalItemCount.get()\r\n                if (shouldPullUpRefresh) {\r\n                    viewModel.isLastItemVisible.set(true)\r\n                    return\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    private fun showCutBinDialog(count: Int, alertType: Utility.AlertType) {\r\n        if (viewModel.userData.value?.cCuttingReminder ?: true) {\r\n            Utility.getCommonAlertDialogue(\r\n                requireContext(),\r\n                \"\",\r\n                resources.getString(R.string.complete_piece, count),\r\n                resources.getString(R.string.no),\r\n                resources.getString(R.string.yes),\r\n                this,\r\n                alertType,\r\n                Utility.Iconype.NONE\r\n            )\r\n        } else {\r\n            adapter?.updatePositionAdapter()\r\n            viewModel.cutCheckBoxClicked(viewModel.cutCount, true)\r\n        }\r\n    }\r\n\r\n    private fun showSplicingForgetDialogue(alertType: Utility.AlertType) {\r\n        Utility.getCommonAlertDialogue(\r\n            requireContext(),\r\n            resources.getString(R.string.complete_cutbin),\r\n            resources.getString(R.string.click_spliced_second_pieces),\r\n            resources.getString(R.string.empty_string),\r\n            resources.getString(R.string.ok),\r\n            this,\r\n            alertType,\r\n            Utility.Iconype.NONE\r\n        )\r\n    }\r\n\r\n    private fun handleEvent(event: WorkspaceViewModel.Event) =\r\n        when (event) {\r\n            is WorkspaceViewModel.Event.OnClickScrollLeft -> {\r\n                binding.recyclerViewPieces.smoothScrollBy(-200, 0)\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickScrollRight -> {\r\n                binding.recyclerViewPieces.smoothScrollBy(200, 0)\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickSaveAndExit -> {\r\n                if (!baseViewModel.isProjecting.get()) {\r\n                    binding.buttonSaveAndExit.isEnabled = false\r\n                    showSaveAndExitPopup()\r\n                    //moveToLibrary()\r\n                } else {\r\n                    showWaitingMessage(\"Projection is under process.. Please wait\")\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickSelectAll -> {\r\n                if (mWorkspaceEditor?.views?.any() ?: false) {\r\n//                    binding.includeWorkspacearea?.layoutSelectAllMask?.visibility = View.VISIBLE\r\n                    viewModel.selectAllText.set(getString(R.string.de_select_all))\r\n                    mWorkspaceEditor?.selectAllSelection()\r\n                } else Utility.showSnackBar(\r\n                    getString(R.string.no_item_in_workspace), binding.topBorder\r\n                )\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickDeSelectAll -> {\r\n//                binding.includeWorkspacearea?.layoutSelectAllMask?.visibility = View.GONE\r\n                viewModel.selectAllText.set(getString(R.string.select_all))\r\n                mWorkspaceEditor?.clearAllSelection()\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickMirrorVertical -> {\r\n                mWorkspaceEditor?.flipVertical()\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickMirrorHorizontal -> {\r\n                mWorkspaceEditor?.flipHorizontal()\r\n            }\r\n            is WorkspaceViewModel.Event.CalculateScrollButtonVisibility -> {\r\n                calculateScrollButtonVisibility()\r\n            }\r\n            is WorkspaceViewModel.Event.OnDataUpdated -> {\r\n                setSelvageImage()\r\n                getScaleFactor()\r\n                setInitialProgressCount()\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickInch -> {\r\n                setSelvageImage()\r\n            }\r\n            is WorkspaceViewModel.Event.ShowMirrorDialog -> {\r\n                if (viewModel.userData.value?.cMirrorReminder ?: true) {\r\n                    Utility.getCommonAlertDialogue(\r\n                        requireContext(),\r\n                        resources.getString(R.string.mirror),\r\n                        resources.getString(R.string.mirror_message),\r\n                        resources.getString(R.string.cancel),\r\n                        resources.getString(R.string.ok),\r\n                        this,\r\n                        Utility.AlertType.MIRROR,\r\n                        Utility.Iconype.NONE\r\n                    )\r\n                } else {\r\n                    if (viewModel.isHorizontalMirror) {\r\n                        mWorkspaceEditor?.flipHorizontal()\r\n                    } else {\r\n                        mWorkspaceEditor?.flipVertical()\r\n                    }\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.DisableMirror -> {\r\n                enableMirror(false)\r\n            }\r\n            is WorkspaceViewModel.Event.EnableMirror -> {\r\n                enableMirror(true)\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickSpliceRight -> {\r\n                mWorkspaceEditor?.clearAllViews()\r\n                if (isSpliceDirectionAvailable(\r\n                        viewModel.workspacedata?.currentSplicedPieceRow ?: 0,\r\n                        viewModel.workspacedata?.currentSplicedPieceColumn?.plus(1) ?: 0,\r\n                        viewModel.workspacedata?.splicedImages\r\n                    )\r\n                ) {\r\n                    viewModel.workspacedata?.currentSplicedPieceColumn =\r\n                        viewModel.workspacedata?.currentSplicedPieceColumn?.plus(1) ?: 0\r\n                    showToWorkspace(true, false);\r\n                    mWorkspaceEditor?.highlightSplicePiece()\r\n                    enableClear(true)\r\n                } else {\r\n                    //TODO\r\n                }\r\n\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickSpliceLeft -> {\r\n                mWorkspaceEditor?.clearAllViews()\r\n                if (isSpliceDirectionAvailable(\r\n                        viewModel.workspacedata?.currentSplicedPieceRow ?: 0,\r\n                        viewModel.workspacedata?.currentSplicedPieceColumn?.minus(1) ?: 0,\r\n                        viewModel.workspacedata?.splicedImages\r\n                    )\r\n                ) {\r\n                    viewModel.workspacedata?.currentSplicedPieceColumn =\r\n                        viewModel.workspacedata?.currentSplicedPieceColumn?.minus(1) ?: 0\r\n                    showToWorkspace(true, false);\r\n                    mWorkspaceEditor?.highlightSplicePiece()\r\n                    enableClear(true)\r\n                } else {\r\n                    //TODO\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickSpliceBottom -> {\r\n                mWorkspaceEditor?.clearAllViews()\r\n                if (isSpliceDirectionAvailable(\r\n                        viewModel.workspacedata?.currentSplicedPieceRow?.minus(1) ?: 0,\r\n                        viewModel.workspacedata?.currentSplicedPieceColumn ?: 0,\r\n                        viewModel.workspacedata?.splicedImages\r\n                    )\r\n                ) {\r\n                    viewModel.workspacedata?.currentSplicedPieceRow =\r\n                        viewModel.workspacedata?.currentSplicedPieceRow?.minus(1) ?: 0\r\n                    showToWorkspace(true, false);\r\n                    mWorkspaceEditor?.highlightSplicePiece()\r\n                    enableClear(true)\r\n                } else {\r\n                    //TODO\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickSpliceTop -> {\r\n                mWorkspaceEditor?.clearAllViews()\r\n                if (isSpliceDirectionAvailable(\r\n                        viewModel.workspacedata?.currentSplicedPieceRow?.plus(1) ?: 0,\r\n                        viewModel.workspacedata?.currentSplicedPieceColumn ?: 0,\r\n                        viewModel.workspacedata?.splicedImages\r\n                    )\r\n                ) {\r\n                    viewModel.workspacedata?.currentSplicedPieceRow =\r\n                        viewModel.workspacedata?.currentSplicedPieceRow?.plus(1) ?: 0\r\n                    showToWorkspace(true, false);\r\n                    mWorkspaceEditor?.highlightSplicePiece()\r\n                    enableClear(true)\r\n                } else {\r\n                    //TODO\r\n                }\r\n            }\r\n\r\n            is WorkspaceViewModel.Event.OnRecalibrateClicked -> {\r\n                if (baseViewModel.isProjecting.get()) {\r\n                    showWaitingMessage(resources.getString(R.string.projection_progress))\r\n                } else {\r\n                    if (baseViewModel.activeSocketConnection.get()) {\r\n                        sendBorderImage()\r\n//                        if (baseViewModel.isUserNeedCalibrated.get()) {\r\n//                            sendBorderImage()\r\n//                        } else {\r\n//                            showCalibrationDialog()\r\n//                        }\r\n                    } else {\r\n                        checkBluetoothWifiPermission()\r\n                    }\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickPatternInstructions -> {\r\n                if (findNavController().currentDestination?.id == R.id.workspaceFragment) {\r\n                    val bundle =\r\n                        bundleOf(\"PatternName\" to viewModel.data.value?.patternPieces?.get(0)?.parentPattern)\r\n                    findNavController().navigate(\r\n                        R.id.action_workspaceFragment_to_pattern_instructions_Fragment,\r\n                        bundle\r\n                    )\r\n                } else {\r\n                    Log.d(\"Error\", \"Invalid currentDestination?.id\")\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.ClearWorkspace -> {\r\n                clearWorkspace()\r\n            }\r\n            is WorkspaceViewModel.Event.CloseScreen -> {\r\n                baseViewModel.isSaveExitButtonClicked.set(true)\r\n                findNavController().popBackStack(R.id.patternDescriptionFragment, false)\r\n                activity?.onBackPressed()\r\n            }\r\n            is WorkspaceViewModel.Event.PopulateWorkspace -> {\r\n                //Loading only the current tab while populating\r\n                //----------------Code change should be done for getting the saved tab------------//\r\n                var workspaceTab: String\r\n                if (viewModel.data?.value?.selectedTab?.length ?: 0 > 1) {\r\n                    workspaceTab = viewModel.data?.value?.selectedTab.toString()\r\n                } else {\r\n                    workspaceTab = resources.getStringArray(R.array.workspace_tabs).get(\r\n                        viewModel.data?.value?.selectedTab?.toInt() ?: 0\r\n                    )\r\n                }\r\n                //-----------------------------------------------------------------------------//\r\n\r\n\r\n                var workspaceItems: MutableList<WorkspaceItems>? = null\r\n                if (viewModel.tabCategory.equals(\"Garment\")) {\r\n                    workspaceItems =\r\n                        viewModel.getWorkspaceDimensions(viewModel.data.value?.garmetWorkspaceItemOfflines) as MutableList<WorkspaceItems>?\r\n                    //workspaceItems = viewModel.data.value?.garmetWorkspaceItemOfflines!!\r\n                } else if (viewModel.tabCategory.equals(\"Lining\")) {\r\n                    workspaceItems =\r\n                        viewModel.getWorkspaceDimensions(viewModel.data.value?.liningWorkspaceItemOfflines) as MutableList<WorkspaceItems>?\r\n\r\n                    //workspaceItems = viewModel.data.value?.liningWorkspaceItemOfflines!!\r\n                } else if (viewModel.tabCategory.equals(\"Interfacing\")) {\r\n                    workspaceItems =\r\n                        viewModel.getWorkspaceDimensions(viewModel.data.value?.interfaceWorkspaceItemOfflines) as MutableList<WorkspaceItems>?\r\n                    //workspaceItems = viewModel.data.value?.interfaceWorkspaceItemOfflines!!\r\n                }\r\n                // set id of workspace item to the oldest large value\r\n                com.ditto.workspace.ui.util.Utility.workspaceItemId.set(\r\n                    workspaceItems?.maxBy { it.id }?.id ?: 0\r\n                )\r\n                var i = 0\r\n                if (workspaceItems != null) {\r\n                    for (workspaceItem in workspaceItems) {\r\n                        i++\r\n                        viewModel.workspacedata = workspaceItem\r\n                        showToWorkspace(i == workspaceItems.size, false)\r\n                    }\r\n                } else {\r\n                    logger.d(\"workspace item is null\")\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.onProject -> {\r\n                viewModel.isProjectionRequest.set(true)\r\n                if (baseViewModel.activeSocketConnection.get()) {\r\n                    startProjecting()\r\n                } else {\r\n                    //checkBluetoothWifiPermission()\r\n                }\r\n            }\r\n            is WorkspaceViewModel.Event.ShowCutBinDialog -> {\r\n                showCutBinDialog(viewModel.cutCount, viewModel.cutType)\r\n                /*if (!viewModel.clicked_spliced_second_pieces.get() && viewModel.spliced_pices_visibility.get()) {\r\n                    //showSplicingForgetDialogue(Utility.AlertType.DEFAULT)\r\n                } else {\r\n                    showCutBinDialog(viewModel.cutCount, viewModel.cutType)\r\n                }*/\r\n            }\r\n            is WorkspaceViewModel.Event.RemoveAllPatternPieces -> {\r\n                clearWorkspace()\r\n                if (mWorkspaceEditor?.views?.size ?: 0 > 0) {\r\n                    viewModel.workspacedata = mWorkspaceEditor?.views?.get(0)\r\n                } else {\r\n                    viewModel.workspacedata = null\r\n                    clearWorkspace()\r\n                }\r\n                adapter?.notifyDataSetChanged()\r\n                onDragCompleted()\r\n            }\r\n            is WorkspaceViewModel.Event.updateProgressCount -> {\r\n                onUpdateProgressCount()\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickClear -> {\r\n                if (mWorkspaceEditor?.views?.any() ?: false) {\r\n                    if (viewModel.selectAllText.get() == (getString(R.string.de_select_all))) {\r\n                        viewModel.selectAllText.set(getString(R.string.select_all))\r\n                        clearWorkspace()\r\n                    } else {\r\n                        mWorkspaceEditor?.removePattern(viewModel.workspacedata, true)\r\n                        if (mWorkspaceEditor?.views?.size!! > 0) {\r\n                            viewModel.workspacedata = mWorkspaceEditor?.views?.get(0)\r\n                            enableClear(false)\r\n                            enableMirror(false)\r\n                            enableSelectAll(true)\r\n                        } else {\r\n                            viewModel.workspacedata = null\r\n                            clearWorkspace()\r\n                        }\r\n                    }\r\n                    viewModel.clickPatternReference(true)\r\n                } else Utility.showSnackBar(\r\n                    getString(R.string.no_item_in_workspace), binding.topBorder\r\n                )\r\n            }\r\n            is WorkspaceViewModel.Event.OnDownloadComplete -> {\r\n\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickTutorial -> {\r\n                navigateToTutorial()\r\n            }\r\n            is WorkspaceViewModel.Event.OnResetClicked -> {\r\n                refreshPatternPiecesAdapter()\r\n            }\r\n            is WorkspaceViewModel.Event.OnClickPatternOrReference -> {\r\n                onUpdateFont()\r\n            }\r\n            is WorkspaceViewModel.Event.DisableClear -> {\r\n                enableClear(false)\r\n            }\r\n            is WorkspaceViewModel.Event.EnableClear -> {\r\n                enableClear(true)\r\n            }\r\n            is WorkspaceViewModel.Event.DisableSelectAll -> {\r\n                enableSelectAll(false)\r\n            }\r\n            is WorkspaceViewModel.Event.EnableSelectAll -> {\r\n                enableSelectAll(true)\r\n            }\r\n        }\r\n\r\n    private fun onUpdateFont() {\r\n        binding.txtPatternPieces.setTypeface(\r\n            ResourcesCompat.getFont(\r\n                requireContext(),\r\n                if (viewModel.clickedPattenPieces.get()) R.font.avenir_next_lt_pro_demi else R.font.avenir_next_lt_pro_regular\r\n            )\r\n        )\r\n        binding.txtReeferanceLayout.setTypeface(\r\n            ResourcesCompat.getFont(\r\n                requireContext(),\r\n                if (viewModel.clickedPattenPieces.get()) R.font.avenir_next_lt_pro_regular else R.font.avenir_next_lt_pro_demi\r\n            )\r\n        )\r\n    }\r\n\r\n    private fun onUpdateProgressCount() {\r\n        binding.seekbarStatus.progress = 0\r\n        binding.seekbarStatus.max = viewModel.data?.value?.totalPieces ?: 0\r\n        binding.seekbarStatus.progress = com.ditto.workspace.ui.util.Utility.progressCount.get()\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        calculateScrollButtonVisibility()\r\n        requireActivity().getWindow()\r\n            ?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)\r\n        requireActivity().getWindow()\r\n            ?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN)\r\n        requireActivity().getWindow()\r\n            ?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN)\r\n        viewModel.isWorkspaceSocketConnection.set(baseViewModel.activeSocketConnection.get())\r\n        if (com.ditto.workspace.ui.util.Utility.isDoubleTapTextVisible.get() != true) {\r\n            viewModel.showDoubleTouchToZoom.set(false)\r\n            // Hide double tap to zoom text after showing\r\n        }\r\n    }\r\n\r\n    override fun onDrag(view: View?, dragEvent: DragEvent?): Boolean {\r\n\r\n        val dragData: DragData? = if (dragEvent?.localState == null) {\r\n            com.ditto.workspace.ui.util.Utility.dragData.get() as DragData?\r\n        } else {\r\n            dragEvent.localState as DragData?\r\n        }\r\n        when (dragEvent?.action) {\r\n            DragEvent.ACTION_DRAG_ENTERED -> {\r\n                if ((dragData?.type == Draggable.SELECT_ALL || dragData?.type == Draggable.DRAG_OUT_WORKSPACE)\r\n                    && (view?.id == R.id.cutbin_lay || view?.id == R.id.recycler_view_pieces)\r\n                ) {\r\n//                    detectTouchedView(view)\r\n                }\r\n            }\r\n            DragEvent.ACTION_DRAG_EXITED, DragEvent.ACTION_DRAG_ENDED -> {\r\n//                if (view?.id == R.id.cutbin_lay) {\r\n//                    binding.imageCutBin.setBackgroundColor(Color.TRANSPARENT)\r\n//                } else if (view?.id == R.id.recycler_view_pieces) {\r\n//                    binding.recyclerViewPieces.setBackgroundColor(Color.TRANSPARENT)\r\n//                }\r\n            }\r\n            DragEvent.ACTION_DROP ->\r\n//                if (view?.id == R.id.cutbin_lay) {\r\n//                    if (dragData?.type == Draggable.SELECT_ALL) {\r\n//                        mWorkspaceEditor?.clearAllSelection()\r\n//                        enableMirror(false)\r\n//                        viewModel.selectAllText.set(getString(R.string.select_all))\r\n//                        mWorkspaceEditor?.views?.let { viewModel.cutSelectAll(it) }\r\n//                    } else if (dragData?.type == Draggable.DRAG_OUT_WORKSPACE) {\r\n//                        val count = dragData?.workspaceItems?.cutQuantity?.get(4)\r\n//                            ?.let { Character.getNumericValue(it) }\r\n//                        cutPieces(count)\r\n//                    }\r\n//                } else if (view?.id == R.id.recycler_view_pieces) {\r\n//                    mWorkspaceEditor?.clearAllSelection()\r\n//                    enableMirror(false)\r\n//                    if (dragData?.type == Draggable.SELECT_ALL) {\r\n//                        viewModel.selectAllText.set(getString(R.string.select_all))\r\n//                        clearWorkspace()\r\n//                    } else if (dragData?.type == Draggable.DRAG_OUT_WORKSPACE) {\r\n//                        mWorkspaceEditor?.removePattern(viewModel.workspacedata, true)\r\n//                        if (mWorkspaceEditor?.views?.size!! > 0) {\r\n//                            viewModel.workspacedata = mWorkspaceEditor?.views?.get(0)\r\n//                        } else {\r\n//                            viewModel.workspacedata = null\r\n//                            clearWorkspace()\r\n//                        }\r\n//                    }\r\n//                    onDragCompleted()\r\n//                } else\r\n                if (view?.id == R.id.layout_workspace) {\r\n                    // set id of initial item to be 0\r\n                    if (mWorkspaceEditor?.views?.size == 0) {\r\n                        com.ditto.workspace.ui.util.Utility.workspaceItemId.set(0)\r\n                    }\r\n                    if (dragData?.type == Draggable.SELECT_TO_WORKSPACE) {\r\n                        enableSelectAll(true)\r\n//                        enableClear(true)\r\n                        if (dragData?.patternPieces?.splice == SPLICE_NO) {\r\n                            if (viewModel.workspacedata?.splice?.equals(SPLICE_YES) == true) {\r\n                                if (viewModel.userData.value?.cSpliceMultiplePieceReminder\r\n                                        ?: true\r\n                                ) {\r\n                                    Utility.getCommonAlertDialogue(\r\n                                        requireActivity(),\r\n                                        resources.getString(R.string.spliced_piece),\r\n                                        resources.getString(R.string.spliced_piece_message),\r\n                                        resources.getString(R.string.empty_string),\r\n                                        resources.getString(R.string.ok),\r\n                                        this,\r\n                                        Utility.AlertType.CUT_BIN,\r\n                                        Utility.Iconype.NONE\r\n                                    )\r\n                                }\r\n                                return true\r\n                            }\r\n                            mWorkspaceEditor?.clearAllSelection()\r\n                            enableMirror(false)\r\n                            com.ditto.workspace.ui.util.Utility.workspaceItemId.set(\r\n                                com.ditto.workspace.ui.util.Utility.workspaceItemId.get() + 1\r\n                            )\r\n                            viewModel.setImageModel(\r\n                                view, dragEvent, dragData,\r\n                                com.ditto.workspace.ui.util.Utility.workspaceItemId.get()\r\n                            )\r\n                            showToWorkspace(true, true)\r\n                        } else {\r\n                            if ((mWorkspaceEditor?.isWorkspaceNotEmpty) != false) {\r\n                                if (viewModel.userData.value?.cSpliceMultiplePieceReminder\r\n                                        ?: true\r\n                                ) {\r\n                                    Utility.getCommonAlertDialogue(\r\n                                        requireActivity(),\r\n                                        resources.getString(R.string.splicing_required),\r\n                                        resources.getString(R.string.splicing_required_message),\r\n                                        resources.getString(R.string.empty_string),\r\n                                        resources.getString(R.string.ok),\r\n                                        this,\r\n                                        Utility.AlertType.CUT_BIN,\r\n                                        Utility.Iconype.NONE\r\n                                    )\r\n                                }\r\n                                return true\r\n                            } else {\r\n                                if (viewModel.userData.value?.cSpliceReminder ?: true) {\r\n                                    if ((dragData?.patternPieces?.splicedImages?.size)!! > 2) {\r\n                                        Utility.getCommonAlertDialogue(\r\n                                            requireActivity(),\r\n                                            resources.getString(R.string.multiple_splicing_required),\r\n                                            resources.getString(R.string.splicing_required_multiple_message),\r\n                                            resources.getString(R.string.empty_string),\r\n                                            resources.getString(R.string.ok),\r\n                                            this,\r\n                                            Utility.AlertType.CUT_BIN,\r\n                                            Utility.Iconype.NONE\r\n                                        )\r\n                                    } else {\r\n\r\n                                        Utility.getCommonAlertDialogue(\r\n                                            requireActivity(),\r\n                                            resources.getString(R.string.splicing_required),\r\n                                            resources.getString(R.string.splicing_required_first_message),\r\n                                            resources.getString(R.string.empty_string),\r\n                                            resources.getString(R.string.ok),\r\n                                            this,\r\n                                            Utility.AlertType.CUT_BIN,\r\n                                            Utility.Iconype.NONE\r\n                                        )\r\n                                    }\r\n                                }\r\n                            }\r\n                            mWorkspaceEditor?.clearAllSelection()\r\n                            enableMirror(false)\r\n                            enableClear(false)\r\n                            viewModel.clickPatternReference(false)\r\n                            com.ditto.workspace.ui.util.Utility.workspaceItemId.set(\r\n                                com.ditto.workspace.ui.util.Utility.workspaceItemId.get() + 1\r\n                            )\r\n                            viewModel.setImageModel(\r\n                                view, dragEvent, dragData,\r\n                                com.ditto.workspace.ui.util.Utility.workspaceItemId.get()\r\n                            )\r\n                            showToWorkspace(true, true)\r\n                        }\r\n                    }\r\n                }\r\n\r\n            else -> {\r\n                Log.d(\"dragger event\", \"undefined\")\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    private fun cutPieces(count: Int?) {\r\n        if (!viewModel.clicked_spliced_second_pieces.get() && viewModel.spliced_pices_visibility.get()) {\r\n            //showSplicingForgetDialogue(Utility.AlertType.DEFAULT)\r\n        } else if (count != null && count > 1 && !viewModel.data.value?.patternPieces?.find { it.id == viewModel.workspacedata?.parentPatternId }?.isCompleted!!) {\r\n            mWorkspaceEditor?.clearAllSelection()\r\n            enableMirror(false)\r\n            showCutBinDialog(count, Utility.AlertType.CUT_BIN)\r\n            cutCount = count\r\n        } else {\r\n            mWorkspaceEditor?.clearAllSelection()\r\n            enableMirror(false)\r\n            if (!viewModel.data.value?.patternPieces?.find { it.id == viewModel.workspacedata?.parentPatternId }?.isCompleted!!) {\r\n                viewModel.data.value?.patternPieces?.find { it.id == viewModel.workspacedata?.parentPatternId }\r\n                    ?.isCompleted = true\r\n                com.ditto.workspace.ui.util.Utility.mPatternPieceList.add(viewModel.workspacedata?.parentPatternId!!)\r\n                adapter?.notifyDataSetChanged()\r\n                viewModel.setCompletedCount(1)\r\n            }\r\n            mWorkspaceEditor?.removePattern(viewModel.workspacedata, true)\r\n            if (mWorkspaceEditor?.views?.size ?: 0 > 0) {\r\n                viewModel.workspacedata = mWorkspaceEditor?.views?.get(0)\r\n            } else {\r\n                viewModel.workspacedata = null\r\n                clearWorkspace()\r\n            }\r\n            onDragCompleted()\r\n        }\r\n    }\r\n\r\n\r\n    private fun detectTouchedView(view: View) {\r\n        val scale = ScaleAnimation(\r\n            0.5F,\r\n            1F,\r\n            0.5F,\r\n            1F,\r\n            ScaleAnimation.RELATIVE_TO_SELF,\r\n            .5f,\r\n            ScaleAnimation.RELATIVE_TO_SELF,\r\n            .5f\r\n        )\r\n        scale.duration = 1500\r\n        scale.fillAfter = true\r\n        scale.interpolator = OvershootInterpolator()\r\n        view.startAnimation(scale)\r\n    }\r\n\r\n    override fun onTouch(view: View, workspaceItem: WorkspaceItems?) {\r\n//        binding.includeWorkspacearea?.layoutSelectAllMask?.visibility = View.GONE\r\n        viewModel.selectAllText.set(getString(R.string.select_all))\r\n        enableClear(true)\r\n        viewModel.workspacedata = workspaceItem\r\n        viewModel.checkMirroring()\r\n    }\r\n\r\n    override fun onSelectAll() {\r\n        Log.d(\"DraggableListener\", \"onSelectAll\")\r\n    }\r\n\r\n    override fun onPositionChanged(view: View, workspaceItem: WorkspaceItems?) {\r\n        val id = viewModel.workspacedata?.id\r\n        viewModel.workspacedata = workspaceItem\r\n        // to fix mirroring issue during multi touch\r\n        if (workspaceItem?.id != id) {\r\n            viewModel.checkMirroring()\r\n        }\r\n        logger.d(\"onpositionchange\")\r\n\r\n    }\r\n\r\n    override fun onDragCompleted() {\r\n        viewModel.isProjectionRequest.set(true)\r\n    }\r\n\r\n    override fun onOverlapped(showToast: Boolean) {\r\n        try {\r\n            if (showToast) {\r\n                Utility.showSnackBar(\r\n                    getString(R.string.overlaping_piece_alert),\r\n                    binding?.workspaceRoot\r\n                )\r\n            }\r\n        } catch (e: java.lang.Exception) {\r\n            logger.d(\"Error : \" + e.message)\r\n        }\r\n    }\r\n\r\n    override fun onProjectWorkspace() {\r\n        Log.d(\"DraggableListener\", \"onProjectWorkspace\")\r\n    }\r\n\r\n    override fun onDragOut(view: View, workspaceItem: WorkspaceItems?) {\r\n        Log.d(\"DraggableListener\", \"onDragOut\")\r\n    }\r\n\r\n    override fun onPositiveButtonClicked(alertType: Utility.AlertType) {\r\n        when (alertType) {\r\n            Utility.AlertType.BLE -> {\r\n                val mBluetoothAdapter =\r\n                    BluetoothAdapter.getDefaultAdapter()\r\n                mBluetoothAdapter.enable()\r\n                if (!Utility.getWifistatus(requireContext())) {\r\n                    showWifiDialogue()\r\n                } else {\r\n                    showConnectivityPopup()\r\n                }\r\n            }\r\n            Utility.AlertType.WIFI -> {\r\n                startActivity(Intent(Settings.ACTION_SETTINGS))\r\n            }\r\n            Utility.AlertType.CALIBRATION -> {\r\n                if (findNavController().currentDestination?.id == R.id.workspaceFragment) {\r\n                    showProgress(toShow = true)\r\n                    GlobalScope.launch { projectBorderImage() }\r\n                }\r\n            }\r\n            Utility.AlertType.QUICK_CHECK -> {\r\n                viewModel.isFromQuickCheck.set(false)\r\n                GlobalScope.launch {\r\n                    Utility.sendDittoImage(\r\n                        requireContext(),\r\n                        \"solid_black\"\r\n                    )\r\n                }\r\n            }\r\n            Utility.AlertType.MIRROR -> {\r\n                if (viewModel.isHorizontalMirror) {\r\n                    mWorkspaceEditor?.flipHorizontal()\r\n                } else {\r\n                    mWorkspaceEditor?.flipVertical()\r\n                }\r\n            }\r\n\r\n            Utility.AlertType.CUT_BIN_ALL -> {\r\n                viewModel.isSingleDelete = false\r\n                viewModel.cutAllPiecesConfirmed(mWorkspaceEditor?.views)\r\n            }\r\n            Utility.AlertType.PATTERN_RENAME -> {\r\n                if (baseViewModel.activeSocketConnection.get()) {\r\n                    GlobalScope.launch {\r\n                        Utility.sendDittoImage(\r\n                            requireActivity(),\r\n                            \"ditto_project\"\r\n                        )\r\n                    }\r\n                }\r\n                viewModel.overridePattern(matchedPattern!!, viewModel.data.value!!, isCompleted)\r\n            }\r\n            Utility.AlertType.CUT_COMPLETE -> {\r\n                adapter?.updatePositionAdapter()\r\n                viewModel.cutCheckBoxClicked(viewModel.cutCount, true)\r\n            }\r\n            else -> {\r\n                Log.d(\"WorkspaceTabfragment\", \"onPositiveButtonClicked\")\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    override fun onNegativeButtonClicked(alertType: Utility.AlertType) {\r\n        when (alertType) {\r\n            Utility.AlertType.BLE -> {\r\n                logger.d(\"Later clicked\")\r\n                baseViewModel.activeSocketConnection.set(false)\r\n                viewModel.isBleLaterClicked.set(true)\r\n            }\r\n            Utility.AlertType.WIFI -> {\r\n                baseViewModel.activeSocketConnection.set(false)\r\n                viewModel.isWifiLaterClicked.set(true)\r\n            }\r\n            Utility.AlertType.CALIBRATION -> {\r\n                viewModel.isFromQuickCheck.set(true)\r\n                sendQuickCheckImage()\r\n            }\r\n            Utility.AlertType.QUICK_CHECK -> {\r\n                viewModel.isFromQuickCheck.set(false)\r\n                GlobalScope.launch { projectBorderImage() }\r\n            }\r\n            Utility.AlertType.CUT_BIN -> {\r\n                mWorkspaceEditor?.removePattern(viewModel.workspacedata, true)\r\n                if (mWorkspaceEditor?.views?.size ?: 0 > 0) {\r\n                    viewModel.workspacedata = mWorkspaceEditor?.views?.get(0)\r\n                } else {\r\n                    viewModel.workspacedata = null\r\n                    clearWorkspace()\r\n                }\r\n                onDragCompleted()\r\n            }\r\n            Utility.AlertType.CUT_BIN_ALL -> {\r\n                viewModel.cutType = Utility.AlertType.CUT_BIN\r\n\r\n            }\r\n            Utility.AlertType.PATTERN_RENAME -> {\r\n                showSaveAndExitPopup()\r\n            }\r\n            else -> {\r\n                Log.d(\"WorkspaceTabfragment\", \"onNegativeButtonClicked\")\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onNeutralButtonClicked() {\r\n        //      TODO(\"Not yet implemented\")\r\n        // No navigation when SKIP button clicked\r\n        //initiateprojection()\r\n    }\r\n\r\n    override fun onSaveButtonClicked(projectName: String, isCompleted: Boolean?) {\r\n\r\n        val a = com.ditto.workspace.ui.util.Utility.fragmentTabs.get().toString()\r\n            if(a.equals(\"0\")){\r\n                viewModel.data.value?.garmetWorkspaceItemOfflines = mWorkspaceEditor?.views?.toMutableList()\r\n                logger.d(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> $a\")\r\n            }else if(a.equals(\"1\")){\r\n                viewModel.data.value?.liningWorkspaceItemOfflines = mWorkspaceEditor?.views?.toMutableList()\r\n                logger.d(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> $a\")\r\n            }else if(a.equals(\"2\")){\r\n                viewModel.data.value?.interfaceWorkspaceItemOfflines = mWorkspaceEditor?.views?.toMutableList()\r\n                logger.d(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> $a\")\r\n            }\r\n        this.isCompleted = isCompleted\r\n        val pattern = checkProjectName(projectName, viewModel.data.value?.id!!)\r\n        if (pattern != null) {\r\n            matchedPattern = pattern\r\n            showSameNameAlert()\r\n        } else {\r\n            if (baseViewModel.activeSocketConnection.get()) {\r\n                GlobalScope.launch {\r\n                    Utility.sendDittoImage(\r\n                        requireActivity(),\r\n                        \"ditto_project\"\r\n                    )\r\n                }\r\n            }\r\n            viewModel.saveProject(projectName, isCompleted,true)\r\n        }\r\n        context?.let { Utility.setSharedPref(it, viewModel.data.value?.id!!) }\r\n    }\r\n\r\n     fun onSaveButtonClicked() {\r\n        val a = com.ditto.workspace.ui.util.Utility.fragmentTabs.get().toString()\r\n         val b= viewModel.selectedTab.get()\r\n            if(a.equals(\"0\")){\r\n                viewModel.data.value?.garmetWorkspaceItemOfflines = mWorkspaceEditor?.views?.toMutableList()\r\n                logger.d(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> $a>>>>>>>$b\")\r\n            }else if(a.equals(\"1\")){\r\n                viewModel.data.value?.liningWorkspaceItemOfflines = mWorkspaceEditor?.views?.toMutableList()\r\n                logger.d(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> $a>>>>>>>$b\")\r\n            }else if(a.equals(\"2\")){\r\n                viewModel.data.value?.interfaceWorkspaceItemOfflines= mWorkspaceEditor?.views?.toMutableList()\r\n                logger.d(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> $a>>>>>>>$b\")\r\n            }\r\n        this.isCompleted = isCompleted\r\n       // val pattern = checkProjectName(projectName, viewModel.data.value?.id!!)\r\n       /* if (pattern != null) {\r\n            matchedPattern = pattern\r\n            showSameNameAlert()\r\n        } else {\r\n            if (baseViewModel.activeSocketConnection.get()) {\r\n                GlobalScope.launch {\r\n                    Utility.sendDittoImage(\r\n                        requireActivity(),\r\n                        \"ditto_project\"\r\n                    )\r\n                }\r\n            }\r\n        }*/\r\n         viewModel.saveProject(\"projectName\", isCompleted,false)\r\n\r\n         context?.let { Utility.setSharedPref(it, viewModel.data.value?.id!!) }\r\n    }\r\n\r\n    private fun checkProjectName(projectName: String, id: Int): PatternsData? {\r\n        return viewModel.allPatterns.value?.filter {\r\n            (it.status == \"Active\").or(it.status == \"Completed\")\r\n        }?.firstOrNull { it.patternName == projectName && it.id != id }\r\n    }\r\n\r\n    private fun showSameNameAlert() {\r\n        getAlertDialogue(\r\n            requireContext(),\r\n            resources.getString(R.string.renameproject),\r\n            resources.getString(R.string.existing_project),\r\n            resources.getString(R.string.rename),\r\n            resources.getString(R.string.override),\r\n            this,\r\n            Utility.AlertType.PATTERN_RENAME\r\n        )\r\n    }\r\n\r\n    override fun onExitButtonClicked() {\r\n        moveToLibrary()\r\n    }\r\n\r\n    private fun moveToLibrary() {\r\n        if (baseViewModel.activeSocketConnection.get()) {\r\n            GlobalScope.launch {\r\n                Utility.sendDittoImage(\r\n                    requireActivity(),\r\n                    \"ditto_project\"\r\n                )\r\n            }\r\n        }\r\n        baseViewModel.isSaveExitButtonClicked.set(true)\r\n        findNavController().popBackStack(R.id.patternDescriptionFragment, false)\r\n        findNavController().popBackStack(R.id.nav_graph_mylibrary, false)\r\n        findNavController().navigate(R.id.nav_graph_id_home)\r\n\r\n        activity?.onBackPressed()\r\n    }\r\n\r\n    private fun enableMirror(status: Boolean) {\r\n        binding.includeWorkspacearea?.txtMirrorV?.alpha = if (status) 1F else 0.5F\r\n        binding.includeWorkspacearea?.txtMirrorH?.alpha = if (status) 1F else 0.5F\r\n        binding.includeWorkspacearea?.txtMirrorV?.isEnabled = status\r\n        binding.includeWorkspacearea?.txtMirrorH?.isEnabled = status\r\n    }\r\n\r\n    private fun enableClear(status: Boolean) {\r\n        binding.includeWorkspacearea?.txtClear?.alpha = if (status) 1F else 0.5F\r\n        binding.includeWorkspacearea?.txtClear?.isEnabled = status\r\n    }\r\n\r\n    private fun enableSelectAll(status: Boolean) {\r\n        binding.includeWorkspacearea?.txtSelectAll?.alpha = if (status) 1F else 0.5F\r\n        binding.includeWorkspacearea?.txtSelectAll?.isEnabled = status\r\n\r\n    }\r\n\r\n    private fun showSaveAndExitPopup() {\r\n        baseViewModel.isSaveExitButtonClicked.set(false)\r\n        onSaveButtonClicked(viewModel.data.value?.patternName.toString(),false)\r\n//        val layout =\r\n//            activity?.layoutInflater?.inflate(R.layout.workspace_save_and_exit_dialog, null)\r\n//        if (viewModel.data.value?.status.equals(\"Completed\") ||\r\n//            (com.ditto.workspace.ui.util.Utility.progressCount.get() == viewModel.data.value?.totalPieces)\r\n//        ) {\r\n//            val checkbox = layout?.findViewById(R.id.complete_checkbox) as CheckBox\r\n//            checkbox.visibility = View.GONE\r\n//        }\r\n//        layout?.let {\r\n//            getAlertDialogSaveAndExit(\r\n//                requireActivity(),\r\n//                resources.getString(R.string.save_and_exit_dialog_title),\r\n//                viewModel.data.value?.patternName\r\n//                    ?: resources.getString(R.string.save_and_exit_dialog_message),\r\n//                it,\r\n//                resources.getString(R.string.exit),\r\n//                resources.getString(R.string.save),\r\n//                this,\r\n//                Utility.AlertType.DEFAULT\r\n//            )\r\n//        }\r\n    }\r\n\r\n    private fun getScaleFactor() {\r\n        val width: Int = binding.includeWorkspacearea.layoutWorkspace.width ?: 1\r\n        val virtualWidth: Int =\r\n            binding.includeWorkspacearea.virtualWorkspaceDimension.width ?: 2520\r\n        val x: Double = (virtualWidth.toDouble().div(width.toDouble()))\r\n        viewModel.scaleFactor.set(x)\r\n        Log.d(\"TAG\", \"scalefactor : \" + viewModel.scaleFactor.get())\r\n    }\r\n\r\n    private fun setInitialProgressCount() {\r\n        var workspaceTab: String\r\n        if (viewModel.data?.value?.selectedTab?.length ?: 0 > 1) {\r\n            workspaceTab = viewModel.data?.value?.selectedTab.toString()\r\n        } else {\r\n            workspaceTab = resources.getStringArray(R.array.workspace_tabs).get(\r\n                viewModel.data?.value?.selectedTab?.toInt() ?: 0\r\n            )\r\n        }\r\n        //-----------------------------------------------------------------------------//\r\n        if (workspaceTab == viewModel.tabCategory) {\r\n            viewModel.data.value?.completedPieces?.let {\r\n                com.ditto.workspace.ui.util.Utility.progressCount.set(\r\n                    it\r\n                )\r\n            }\r\n            binding.seekbarStatus.progress = 0\r\n            binding.seekbarStatus.max = viewModel.data?.value?.totalPieces ?: 0\r\n            binding.seekbarStatus.progress = com.ditto.workspace.ui.util.Utility.progressCount.get()\r\n            logger.d(\"TRACE: Fetched progress count \" + com.ditto.workspace.ui.util.Utility.progressCount.get())\r\n        }\r\n    }\r\n\r\n    /*\r\n    Displaying pieces in Workspace\r\n     */\r\n    private fun showToWorkspace(showProjection: Boolean, isDraggedPiece: Boolean) {\r\n        viewModel.spliced_pices_visibility.set(false)\r\n        viewModel.clicked_spliced_second_pieces.set(false)\r\n        if (com.ditto.workspace.ui.util.Utility.isDoubleTapTextVisible.get()) {\r\n            viewModel.showDoubleTouchToZoom.set(true)\r\n        }\r\n        viewModel.selectAllText.set(getString(R.string.select_all))\r\n        mWorkspaceEditor?.clearAllSelection()\r\n        var imagename = viewModel.workspacedata?.imagePath\r\n        if (viewModel.workspacedata?.splice?.equals(SPLICE_YES) == true) {\r\n            showSpliceArrows(\r\n                viewModel.workspacedata?.currentSplicedPieceRow ?: 0,\r\n                viewModel.workspacedata?.currentSplicedPieceColumn ?: 0\r\n            )\r\n\r\n            val splicePiece = getSplicePiece(\r\n                viewModel.workspacedata?.currentSplicedPieceRow ?: 0,\r\n                viewModel.workspacedata?.currentSplicedPieceColumn ?: 0,\r\n                viewModel.workspacedata?.splicedImages\r\n            )\r\n\r\n            // Setting splice reference layout\r\n            showSpliceReference(splicePiece)\r\n            binding.txtSizeSplice.isEnabled = true\r\n            viewModel.enableSplice.set(true)\r\n            viewModel.clickedSplice.set(true)\r\n            viewModel.clickedSize45.set(false)\r\n            viewModel.clickedSize60.set(false)\r\n\r\n            imagename = splicePiece?.imagePath\r\n            viewModel.workspacedata?.splicedImages?.size?.let {\r\n                viewModel.splice_pices_count.set(\r\n                    it\r\n                )\r\n            }\r\n            viewModel.spliced_pices_visibility.set(true)\r\n        }\r\n        var theBitmap: Bitmap? = imagename?.let { getBitmapFromSvgPngDrawable(it) }\r\n        if (imagename != null) {\r\n            mWorkspaceEditor?.addImage(\r\n                theBitmap,\r\n                viewModel.workspacedata,\r\n                viewModel.scaleFactor.get(),\r\n                showProjection,\r\n                isDraggedPiece,\r\n                this@WorkspaceTabFragment\r\n            )\r\n        }\r\n        // TODO To be included when using API images\r\n//        var theBitmap: Bitmap? = null\r\n//        GlobalScope.launch {\r\n//            try {\r\n//                showProgress(toShow = true)\r\n////                imagename = \"https://splicing-app.s3.us-east-2.amazonaws.com/demo-user-id/M7987_36_C_1.svg\"\r\n////                imagename = \"https://splicing-app.s3.us-east-2.amazonaws.com/demo-user-id/thumbnailImageUrl_.png\"\r\n//                theBitmap = imagename?.let { getBitmapFromSvgPngDrawable(it) }\r\n//                withContext(Dispatchers.Main) {\r\n//                    if (imagename != null) {\r\n//                        mWorkspaceEditor?.addImage(\r\n//                            theBitmap,\r\n//                            viewModel.workspacedata,\r\n//                            viewModel.scaleFactor.get(),\r\n//                            showProjection,\r\n//                            isDraggedPiece,\r\n//                            this@WorkspaceTabFragment\r\n//                        )\r\n//                    }\r\n//                }\r\n//            } catch (e: Exception) {\r\n//                e.printStackTrace()\r\n//            }finally {\r\n//                showProgress(toShow = false)\r\n//            }\r\n//        }\r\n\r\n    }\r\n\r\n\r\n    private fun getBitmapFromSvgPngDrawable(imagePath: String): Bitmap? {\r\n        return if (imagePath.endsWith(\".svg\", true)) {\r\n            Glide\r\n                .with(context)\r\n                .load(imagePath)\r\n                .asBitmap()\r\n                .diskCacheStrategy(DiskCacheStrategy.NONE)\r\n                .placeholder(R.drawable.ic_launcher_background)\r\n                .imageDecoder(SvgBitmapDecoder(context))\r\n                .into(SIZE_ORIGINAL, SIZE_ORIGINAL)\r\n                .get()\r\n        } else if (imagePath.endsWith(\".png\", true)) {\r\n            Glide\r\n                .with(context)\r\n                .load(imagePath)\r\n                .asBitmap()\r\n                .diskCacheStrategy(DiskCacheStrategy.NONE)\r\n                .placeholder(R.drawable.ic_launcher_background)\r\n                .into(SIZE_ORIGINAL, SIZE_ORIGINAL)\r\n                .get()\r\n        } else {\r\n            getBitmap(getDrawableFromString(context, imagePath) as VectorDrawable, false, false)\r\n        }\r\n    }\r\n\r\n    private fun showSpliceReference(spliceImages: SpliceImages?) {\r\n        spliceImages?.reference_splice.let {\r\n            binding.imageSelvageHorizontal.setImageDrawable(\r\n                getDrawableFromString(context, it)\r\n            )\r\n        }\r\n        viewModel.referenceImage.set(spliceImages?.reference_splice)\r\n    }\r\n\r\n    private fun showSpliceArrows(row: Int?, column: Int?) {\r\n        if (isSpliceDirectionAvailable(\r\n                row ?: 0,\r\n                column?.plus(1) ?: 0,\r\n                viewModel.workspacedata?.splicedImages\r\n            )\r\n        ) {\r\n//            layout_workspace_background.setBackgroundResource(R.drawable.ic_workspace_splice_right_new)\r\n            splice_right.bringToFront()\r\n            viewModel.isSpliceRightVisible.set(true)\r\n            viewModel.spliced_pices.set(1)\r\n        }\r\n        if (isSpliceDirectionAvailable(\r\n                row ?: 0,\r\n                column?.minus(1) ?: 0,\r\n                viewModel.workspacedata?.splicedImages\r\n            )\r\n        ) {\r\n//            layout_workspace_background.setBackgroundResource(R.drawable.ic_workspace_splice_left_new)\r\n            splice_left.bringToFront()\r\n            viewModel.isSpliceLeftVisible.set(true)\r\n            viewModel.spliced_pices.set(2)\r\n            viewModel.clicked_spliced_second_pieces.set(true)\r\n        }\r\n        if (isSpliceDirectionAvailable(\r\n                row?.plus(1) ?: 0,\r\n                column ?: 0,\r\n                viewModel.workspacedata?.splicedImages\r\n            )\r\n        ) {\r\n//            layout_workspace_background.setBackgroundResource(R.drawable.ic_workspace_splice_top_new)\r\n            splice_top.bringToFront()\r\n            viewModel.isSpliceTopVisible.set(true)\r\n            viewModel.spliced_pices.set(1)\r\n        }\r\n        if (isSpliceDirectionAvailable(\r\n                row?.minus(1) ?: 0,\r\n                column ?: 0,\r\n                viewModel.workspacedata?.splicedImages\r\n            )\r\n        ) {\r\n//            layout_workspace_background.setBackgroundResource(R.drawable.ic_workspace_splice_bottom_new)\r\n            splice_bottom.bringToFront()\r\n            viewModel.isSpliceBottomVisible.set(true)\r\n            viewModel.spliced_pices.set(2)\r\n            viewModel.clicked_spliced_second_pieces.set(true) // works only for saved project\r\n        }\r\n    }\r\n\r\n\r\n    private fun isSpliceDirectionAvailable(\r\n        row: Int,\r\n        column: Int,\r\n        spliceImageList: List<SpliceImages>?\r\n    ): Boolean {\r\n        val isSplicePossible = spliceImageList?.filter {\r\n            it.row == row && it.column == column\r\n        }\r\n        return !isSplicePossible.isNullOrEmpty()\r\n    }\r\n\r\n    private fun getSplicePiece(\r\n        row: Int,\r\n        column: Int,\r\n        spliceImageList: List<SpliceImages>?\r\n    ): SpliceImages? {\r\n        val spliceImage = spliceImageList?.filter {\r\n            it.row == row && it.column == column\r\n        }?.get(0)\r\n        return spliceImage\r\n    }\r\n\r\n    fun getVirtualWorkspace(): Bitmap {\r\n        val workspaceItems: List<WorkspaceItems> =\r\n            mWorkspaceEditor?.views ?: emptyList()\r\n        // added +5 inorder to fix the right and bottom cut in projection\r\n        val bitmapWidth =\r\n            Math.ceil(\r\n                layout_workspace?.measuredWidth?.plus(5)?.times(viewModel.scaleFactor.get())\r\n                    ?: 0.0\r\n            ).toInt()\r\n        val bitmapHeight = bitmapWidth / 14 * 9\r\n        val bigBitmap = Bitmap.createBitmap(\r\n            bitmapWidth, bitmapHeight,\r\n            Bitmap.Config.ARGB_8888\r\n        )\r\n        val canvas = Canvas(bigBitmap)\r\n        for (workspaceItem in workspaceItems) {\r\n//            val myIcon: Drawable?\r\n//            if (workspaceItem.splice.equals(SPLICE_YES) == true) {\r\n//                myIcon = getDrawableFromString(\r\n//                    context,\r\n//                    getSplicePiece(\r\n//                        workspaceItem.currentSplicedPieceRow,\r\n//                        workspaceItem.currentSplicedPieceColumn,\r\n//                        workspaceItem.splicedImages\r\n//                    )?.imagePath\r\n//                )\r\n//            } else {\r\n//                myIcon = getDrawableFromString(context, workspaceItem.imagePath)\r\n//            }\r\n//\r\n//            val bitmap = getBitmap(\r\n//                myIcon as VectorDrawable,\r\n//                workspaceItem.isMirrorV,\r\n//                workspaceItem.isMirrorH\r\n//            )\r\n\r\n            val imagename: String?\r\n            if (workspaceItem.splice.equals(SPLICE_YES) == true) {\r\n                imagename = getSplicePiece(\r\n                    workspaceItem.currentSplicedPieceRow,\r\n                    workspaceItem.currentSplicedPieceColumn,\r\n                    workspaceItem.splicedImages\r\n                )?.imagePath\r\n            } else {\r\n                imagename  = workspaceItem.imagePath\r\n            }\r\n            var bitmap: Bitmap? = imagename?.let { getBitmapFromSvgPngDrawable(it) }\r\n\r\n\r\n            val matrix = Matrix()\r\n            matrix.preTranslate(\r\n                workspaceItem.xcoordinate.times(viewModel.scaleFactor.get().toFloat()),\r\n                workspaceItem.ycoordinate.times(viewModel.scaleFactor.get().toFloat())\r\n            )\r\n            val pivotx =\r\n                (bitmap?.width)?.toFloat()?.div(2)\r\n            val pivoty =\r\n                bitmap?.height?.toFloat()?.div(2)\r\n\r\n            matrix.preRotate(\r\n                workspaceItem.rotationAngle,\r\n                pivotx ?: workspaceItem.pivotX.times(viewModel.scaleFactor.get().toFloat()),\r\n                pivoty ?: workspaceItem.pivotY.times(viewModel.scaleFactor.get().toFloat())\r\n            )\r\n            //**********************\r\n            bitmap?.let {\r\n                canvas.drawBitmap(\r\n                    it,\r\n                    matrix,\r\n                    null\r\n                )\r\n            }\r\n            matrix.reset()\r\n            //******************************\r\n        }\r\n        return bigBitmap\r\n    }\r\n\r\n    /**\r\n     * Variable creations\r\n     */\r\n    companion object {\r\n        private const val PROJECTING_TIME = 10\r\n        private const val PATTERN_CATEGORY = \"PatternCategory\"\r\n        private const val PATTERN_ID = \"PatternId\"\r\n        private const val SPLICE_NO = \"NO\"\r\n        private const val SPLICE_YES = \"YES\"\r\n        private const val SPLICE_LEFT_TO_RIGHT = \"Splice Left-to-Right\"\r\n        private const val SPLICE_TOP_TO_BOTTOM = \"Splice Top-to-Bottom\"\r\n        private const val MULTIPLE_TO_MULTIPLE = \"Splice Multiple-to-Multiple\"\r\n        private const val REQUEST_CODE_PERMISSIONS = 111\r\n        private const val REQUEST_ACTIVITY_RESULT_CODE = 131\r\n        private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.BLUETOOTH)\r\n\r\n    }\r\n\r\n    private fun showBluetoothDialogue() {\r\n        /*getAlertDialogue(\r\n            requireContext(),\r\n            resources.getString(R.string.ditto_connect),\r\n            resources.getString(R.string.ble_connectivity),\r\n            resources.getString(R.string.skips),\r\n            resources.getString(R.string.turnon),\r\n            this,\r\n            Utility.AlertType.BLE\r\n        )*/\r\n\r\n        Utility.getCommonAlertDialogue(\r\n            requireContext(),\r\n            \"Connectivity\",\r\n            \"This app needs Bluetooth connectivity\",\r\n            \"LATER\",\r\n            resources.getString(R.string.turnon),\r\n            this,\r\n            Utility.AlertType.BLE,\r\n            Utility.Iconype.SUCCESS\r\n        )\r\n    }\r\n\r\n    private fun showWifiDialogue() {\r\n\r\n        /*getAlertDialogue(\r\n            requireContext(),\r\n            resources.getString(R.string.ditto_connect),\r\n            resources.getString(R.string.wifi_connectivity),\r\n            resources.getString(R.string.skips),\r\n            resources.getString(R.string.settings),\r\n            this,\r\n            Utility.AlertType.WIFI\r\n        )*/\r\n\r\n        Utility.getCommonAlertDialogue(\r\n            requireContext(),\r\n            \"Connectivity\",\r\n            \"This app needs WiFi connectivity\",\r\n            \"LATER\",\r\n            \"SETTINGS\",\r\n            this,\r\n            Utility.AlertType.WIFI,\r\n            Utility.Iconype.SUCCESS\r\n        )\r\n\r\n    }\r\n\r\n    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {\r\n        context?.let { it1 ->\r\n            ContextCompat.checkSelfPermission(\r\n                it1, it\r\n            )\r\n        } == PackageManager.PERMISSION_GRANTED\r\n    }\r\n\r\n    private fun checkBluetoothWifiPermission() {\r\n        if (allPermissionsGranted()) {\r\n            if (!Utility.getBluetoothstatus()) {\r\n                showBluetoothDialogue()\r\n            } else if (!Utility.getWifistatus(requireContext())) {\r\n                showWifiDialogue()\r\n            } else {\r\n                showConnectivityPopup()\r\n            }\r\n        } else {\r\n            requestPermissions(\r\n                REQUIRED_PERMISSIONS,\r\n                REQUEST_CODE_PERMISSIONS\r\n            )\r\n        }\r\n    }\r\n\r\n    private fun showConnectivityPopup() {\r\n        val intent = Intent(requireContext(), ConnectivityActivity::class.java)\r\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)\r\n        startActivityForResult(\r\n            intent,\r\n            REQUEST_ACTIVITY_RESULT_CODE\r\n        )\r\n    }\r\n\r\n    private fun showCalibrationDialog() {\r\n        /*getAlertDialogue(\r\n            requireContext(),\r\n            resources.getString(R.string.setup_calibration_title),\r\n            resources.getString(R.string.setup_calibration_message),\r\n            resources.getString(R.string.setup_calibration_quickcheck),\r\n            resources.getString(R.string.setup_calibration_calibrate),\r\n            resources.getString(R.string.skips),\r\n            this,\r\n            Utility.AlertType.CALIBRATION\r\n        )*/\r\n\r\n        val layout =\r\n            activity?.layoutInflater?.inflate(R.layout.alert_calibration_confirmation, null)\r\n        val dialogBuilder =\r\n            AlertDialog.Builder(requireContext())\r\n        dialogBuilder.setCancelable(false)\r\n        val alertCalibration = dialogBuilder.create()\r\n        alertCalibration.setView(layout)\r\n        alertCalibration.show()\r\n        val negative = layout?.findViewById(R.id.textNegative) as TextView\r\n        val positive = layout.findViewById(R.id.textYes) as TextView\r\n        positive.setOnClickListener {\r\n            alertCalibration.dismiss()\r\n            baseViewModel.isCalibrated.set(false)\r\n            viewModel.isWorkspaceIsCalibrated.set(baseViewModel.isCalibrated.get())\r\n//            baseViewModel.isUserNeedCalibrated.set(true)\r\n            //sendBorderImage()\r\n        }\r\n        negative.setOnClickListener {\r\n            alertCalibration.dismiss()\r\n            baseViewModel.isCalibrated.set(true)\r\n            viewModel.isWorkspaceIsCalibrated.set(baseViewModel.isCalibrated.get())\r\n//            baseViewModel.isUserNeedCalibrated.set(false)\r\n            /*if (baseViewModel.activeSocketConnection.get()) {\r\n                GlobalScope.launch { Utility.sendDittoImage(requireActivity(), \"solid_black\") }\r\n            }*/\r\n\r\n        }\r\n    }\r\n\r\n    private fun sendBorderImage() {\r\n        if (findNavController().currentDestination?.id == R.id.workspaceFragment) {\r\n            showProgress(toShow = true)\r\n            GlobalScope.launch { projectBorderImage() }\r\n        }\r\n    }\r\n\r\n    private fun showQuickCheckDialog() {\r\n        getAlertDialogue(\r\n            requireContext(),\r\n            resources.getString(R.string.setup_quickcheck_title),\r\n            resources.getString(R.string.setup_quickcheck_message),\r\n            resources.getString(R.string.calibrate),\r\n            resources.getString(R.string.yes_string),\r\n            this,\r\n            Utility.AlertType.QUICK_CHECK\r\n        )\r\n    }\r\n\r\n    /**\r\n     * [Function] Calibration Button Click\r\n     */\r\n    private fun showcalibrationbuttonclicked() {\r\n        val layout =\r\n            activity?.layoutInflater?.inflate(R.layout.calibration_camera_alert_ws, null)\r\n\r\n        /* val dialogBuilder =\r\n             AlertDialog.Builder(\r\n                 ContextThemeWrapper(\r\n                     requireContext(),\r\n                     R.style.AlertDialogCustom\r\n                 )\r\n             )*/\r\n        val dialogBuilder = AlertDialog.Builder(requireContext())\r\n        dialogBuilder.setCancelable(false)\r\n        /*.setNegativeButton(\r\n            getString(R.string.cancel),\r\n            DialogInterface.OnClickListener { dialog, id ->\r\n                dialog.dismiss()\r\n            })\r\n        .setPositiveButton(\r\n            getString(R.string.launch_camera),\r\n            DialogInterface.OnClickListener { dialog, id ->\r\n                dialog.dismiss()\r\n                sendCalibrationPattern()\r\n            })*/\r\n\r\n        val alertCamera = dialogBuilder.create()\r\n        alertCamera.setView(layout)\r\n        // alertCamera.window?.setLayout(535,201)\r\n        alertCamera.show()\r\n        val cancel = layout?.findViewById(R.id.textCancel) as TextView\r\n        val launch = layout.findViewById(R.id.textLaunch) as TextView\r\n        launch.setOnClickListener {\r\n            alertCamera.dismiss()\r\n            sendCalibrationPattern()\r\n        }\r\n        cancel.setOnClickListener {\r\n            alertCamera.dismiss()\r\n            if (baseViewModel.activeSocketConnection.get()) {\r\n                GlobalScope.launch { Utility.sendDittoImage(requireActivity(), \"solid_black\") }\r\n            }\r\n        }\r\n        val displayMetrics = DisplayMetrics()\r\n        requireActivity().windowManager.getDefaultDisplay().getMetrics(displayMetrics)\r\n        val displayWidth: Int = displayMetrics.widthPixels\r\n        val displayHeight: Int = displayMetrics.heightPixels\r\n        val layoutParams: WindowManager.LayoutParams = WindowManager.LayoutParams()\r\n        layoutParams.copyFrom(alertCamera.window?.attributes)\r\n        val dialogWindowWidth = (displayWidth * 0.8f).toInt()\r\n        val dialogWindowHeight = (displayHeight * 0.6f).toInt()\r\n        layoutParams.width = dialogWindowWidth\r\n        layoutParams.height = dialogWindowHeight\r\n        alertCamera.window?.attributes = layoutParams\r\n    }\r\n\r\n    private fun sendCalibrationPattern() {\r\n        logger.d(\"TRACE_ Projection : sendCalibrationPattern start \" + Calendar.getInstance().timeInMillis)\r\n        showProgress(true)\r\n        val bitmap =\r\n            Utility.getBitmapFromDrawable(\r\n                \"calibration_pattern\",\r\n                requireContext()\r\n            )\r\n        viewModel.disposable += Observable.fromCallable {\r\n            performTransform(\r\n                bitmap,\r\n                context?.applicationContext,\r\n                Utility.unityTransParmsString,\r\n                false\r\n            )\r\n        }\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(AndroidSchedulers.mainThread())\r\n            .subscribeBy { handleResult(it, true) }\r\n    }\r\n\r\n    private fun sendQuickCheckImage() {\r\n        showProgress(true)\r\n        val bitmap =\r\n            Utility.getBitmapFromDrawable(\r\n                \"quick_check_pattern\",\r\n                requireContext()\r\n            )\r\n        transform(bitmap, false)\r\n    }\r\n\r\n    private suspend fun projectBorderImage() {\r\n        withContext(Dispatchers.IO) {\r\n            val bitmap =\r\n                Utility.getBitmapFromDrawable(\r\n                    \"setup_pattern_border\",\r\n                    requireContext()\r\n                )\r\n            var soc: Socket? = null\r\n            try {\r\n                soc = Socket(\r\n                    core.network.NetworkUtility.nsdSericeHostName,\r\n                    core.network.NetworkUtility.nsdSericePortName\r\n                )\r\n                if (soc.isConnected) {\r\n                    val workspaceStream = ByteArrayOutputStream()\r\n                    bitmap.compress(Bitmap.CompressFormat.PNG, 0, workspaceStream)\r\n                    val bitmapdata = workspaceStream.toByteArray()\r\n                    bitmap.recycle()\r\n                    val dataOutputStream: DataOutputStream =\r\n                        DataOutputStream(soc.getOutputStream())\r\n                    dataOutputStream.write(bitmapdata)\r\n                    dataOutputStream.close()\r\n                    withContext(Dispatchers.Main) {\r\n                        showProgress(toShow = false)\r\n                        showcalibrationbuttonclicked()\r\n                    }\r\n                } else {\r\n                    baseViewModel.activeSocketConnection.set(false)\r\n                    baseViewModel.isProjecting.set(false)\r\n                    viewModel.isProjectionRequest.set(false)\r\n                    withContext(Dispatchers.Main) {\r\n                        showProgress(toShow = false)\r\n                        showFailurePopup()\r\n                    }\r\n                }\r\n            } catch (e: Exception) {\r\n                baseViewModel.activeSocketConnection.set(false)\r\n                baseViewModel.isProjecting.set(false)\r\n                viewModel.isProjectionRequest.set(false)\r\n                logger.d(\"Exception \" + e.message)\r\n                withContext(Dispatchers.Main) {\r\n                    showProgress(toShow = false)\r\n                    showFailurePopup()\r\n                }\r\n            } finally {\r\n                soc?.close()\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun navigateToCalibration() {\r\n        // Moving to calibration fragment\r\n        findNavController().navigate(\r\n            R.id.action_workspace_to_calibration,\r\n            bundleOf(\r\n                \"PatternId\" to viewModel.patternId.get(),\r\n                \"isFromPatternDescription\" to true,\r\n                \"isRecalibrate\" to true\r\n            )\r\n        )\r\n    }\r\n\r\n    private fun navigateToTutorial() {\r\n        val bundle = bundleOf(\"isFromHome\" to true)\r\n        findNavController().navigate(R.id.action_workspace_to_tutorial, bundle)\r\n\r\n    }\r\n\r\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\r\n        super.onActivityResult(requestCode, resultCode, data)\r\n        logger.d(\"On Activity Result\")\r\n        if (requestCode == REQUEST_ACTIVITY_RESULT_CODE) {\r\n            if (data?.data.toString().equals(\"success\")) {\r\n                showWaitingMessage(\"Connected to Ditto Projector!!\")\r\n                baseViewModel.activeSocketConnection.set(true)\r\n                viewModel.isWorkspaceSocketConnection.set(baseViewModel.activeSocketConnection.get())\r\n                showCalibrationDialog()\r\n                // clear workspace\r\n                GlobalScope.launch {\r\n                    Utility.sendDittoImage(\r\n                        requireContext(),\r\n                        \"solid_black\"\r\n                    )\r\n                }\r\n\r\n            } else {\r\n                baseViewModel.activeSocketConnection.set(false)\r\n                viewModel.isWorkspaceSocketConnection.set(baseViewModel.activeSocketConnection.get())\r\n                //txt_recalibrate.setText(\"Connect\")\r\n                logger.d(\"\")\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun showFailurePopup() {\r\n        Utility.getCommonAlertDialogue(\r\n            requireActivity(),\r\n            \"\",\r\n            \"Projector connection failed\",\r\n            \"CANCEL\",\r\n            \"RETRY\",\r\n            this,\r\n            Utility.AlertType.CONNECTIVITY,\r\n            Utility.Iconype.FAILED\r\n        )\r\n\r\n    }\r\n\r\n    override fun onCustomPositiveButtonClicked(\r\n        iconype: Utility.Iconype,\r\n        alertType: Utility.AlertType\r\n    ) {\r\n        when (alertType) {\r\n            Utility.AlertType.BLE -> {\r\n                val mBluetoothAdapter =\r\n                    BluetoothAdapter.getDefaultAdapter()\r\n                mBluetoothAdapter.enable()\r\n                if (!Utility.getWifistatus(requireContext())) {\r\n                    showWifiDialogue()\r\n                } else {\r\n                    showConnectivityPopup()\r\n                }\r\n            }\r\n            Utility.AlertType.WIFI -> {\r\n                startActivity(Intent(Settings.ACTION_SETTINGS))\r\n            }\r\n            Utility.AlertType.CALIBRATION -> {\r\n                if (findNavController().currentDestination?.id == R.id.workspaceFragment) {\r\n                    showProgress(toShow = true)\r\n                    GlobalScope.launch { projectBorderImage() }\r\n                }\r\n            }\r\n            Utility.AlertType.QUICK_CHECK -> {\r\n                viewModel.isFromQuickCheck.set(false)\r\n                GlobalScope.launch {\r\n                    Utility.sendDittoImage(\r\n                        requireContext(),\r\n                        \"solid_black\"\r\n                    )\r\n                }\r\n            }\r\n            Utility.AlertType.MIRROR -> {\r\n                if (viewModel.isHorizontalMirror) {\r\n                    mWorkspaceEditor?.flipHorizontal()\r\n                } else {\r\n                    mWorkspaceEditor?.flipVertical()\r\n                }\r\n            }\r\n\r\n            Utility.AlertType.CUT_BIN_ALL -> {\r\n                viewModel.isSingleDelete = false\r\n                viewModel.cutAllPiecesConfirmed(mWorkspaceEditor?.views)\r\n            }\r\n            Utility.AlertType.PATTERN_RENAME -> {\r\n                if (baseViewModel.activeSocketConnection.get()) {\r\n                    GlobalScope.launch {\r\n                        Utility.sendDittoImage(\r\n                            requireActivity(),\r\n                            \"ditto_project\"\r\n                        )\r\n                    }\r\n                }\r\n                viewModel.overridePattern(matchedPattern!!, viewModel.data.value!!, isCompleted)\r\n            }\r\n            Utility.AlertType.CUT_COMPLETE -> {\r\n                adapter?.updatePositionAdapter()\r\n                viewModel.cutCheckBoxClicked(viewModel.cutCount, true)\r\n            }\r\n            Utility.AlertType.MIRROR -> {\r\n                if (viewModel.isHorizontalMirror) {\r\n                    mWorkspaceEditor?.flipHorizontal()\r\n                } else {\r\n                    mWorkspaceEditor?.flipVertical()\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    override fun onCustomNegativeButtonClicked(\r\n        iconype: Utility.Iconype,\r\n        alertType: Utility.AlertType\r\n    ) {\r\n        when (alertType) {\r\n            Utility.AlertType.BLE -> {\r\n                logger.d(\"Later clicked\")\r\n                baseViewModel.activeSocketConnection.set(false)\r\n                viewModel.isBleLaterClicked.set(true)\r\n            }\r\n            Utility.AlertType.WIFI -> {\r\n                baseViewModel.activeSocketConnection.set(false)\r\n                viewModel.isWifiLaterClicked.set(true)\r\n            }\r\n            Utility.AlertType.CONNECTIVITY -> {\r\n                viewModel.isWorkspaceSocketConnection.set(baseViewModel.activeSocketConnection.get())\r\n            }\r\n            Utility.AlertType.CUT_BIN -> {\r\n                mWorkspaceEditor?.removePattern(viewModel.workspacedata, true)\r\n                if (mWorkspaceEditor?.views?.size ?: 0 > 0) {\r\n                    viewModel.workspacedata = mWorkspaceEditor?.views?.get(0)\r\n                } else {\r\n                    viewModel.workspacedata = null\r\n                    clearWorkspace()\r\n                }\r\n                onDragCompleted()\r\n            }\r\n            Utility.AlertType.CUT_BIN_ALL -> {\r\n                viewModel.cutType = Utility.AlertType.CUT_BIN\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    fun resetWorkspaceUI() {\r\n        setConnectButton()\r\n        if (com.ditto.workspace.ui.util.Utility.progressCount.get() == 0) {\r\n            resetPatternPiecesAdapter()\r\n        }\r\n    }\r\n\r\n    private fun setConnectButton() {\r\n        viewModel.isWorkspaceSocketConnection.set(baseViewModel.activeSocketConnection.get())\r\n        viewModel.isWorkspaceIsCalibrated.set(baseViewModel.isCalibrated.get())\r\n        if (baseViewModel.isSetUpError.get()) {\r\n            baseViewModel.isSetUpError.set(false)\r\n            viewModel.onClickRecalibrate()\r\n        }\r\n    }\r\n\r\n    private fun resetPatternPiecesAdapter() {\r\n        (binding.recyclerViewPieces.adapter as PatternPiecesAdapter)?.viewModel.clearPatternsSelected()\r\n        binding.recyclerViewPieces.adapter?.notifyDataSetChanged()\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- workspace/ui/src/main/java/com/ditto/workspace/ui/WorkspaceTabFragment.kt	(revision b1a9112ed1ce2865cf8c5448cc6c73d09b414055)
+++ workspace/ui/src/main/java/com/ditto/workspace/ui/WorkspaceTabFragment.kt	(date 1629432437660)
@@ -1569,43 +1569,43 @@
             }
             viewModel.spliced_pices_visibility.set(true)
         }
-        var theBitmap: Bitmap? = imagename?.let { getBitmapFromSvgPngDrawable(it) }
-        if (imagename != null) {
-            mWorkspaceEditor?.addImage(
-                theBitmap,
-                viewModel.workspacedata,
-                viewModel.scaleFactor.get(),
-                showProjection,
-                isDraggedPiece,
-                this@WorkspaceTabFragment
-            )
-        }
-        // TODO To be included when using API images
-//        var theBitmap: Bitmap? = null
-//        GlobalScope.launch {
-//            try {
-//                showProgress(toShow = true)
-////                imagename = "https://splicing-app.s3.us-east-2.amazonaws.com/demo-user-id/M7987_36_C_1.svg"
-////                imagename = "https://splicing-app.s3.us-east-2.amazonaws.com/demo-user-id/thumbnailImageUrl_.png"
-//                theBitmap = imagename?.let { getBitmapFromSvgPngDrawable(it) }
-//                withContext(Dispatchers.Main) {
-//                    if (imagename != null) {
-//                        mWorkspaceEditor?.addImage(
-//                            theBitmap,
-//                            viewModel.workspacedata,
-//                            viewModel.scaleFactor.get(),
-//                            showProjection,
-//                            isDraggedPiece,
-//                            this@WorkspaceTabFragment
-//                        )
-//                    }
-//                }
-//            } catch (e: Exception) {
-//                e.printStackTrace()
-//            }finally {
-//                showProgress(toShow = false)
-//            }
+//        var theBitmap: Bitmap? = imagename?.let { getBitmapFromSvgPngDrawable(it) }
+//        if (imagename != null) {
+//            mWorkspaceEditor?.addImage(
+//                theBitmap,
+//                viewModel.workspacedata,
+//                viewModel.scaleFactor.get(),
+//                showProjection,
+//                isDraggedPiece,
+//                this@WorkspaceTabFragment
+//            )
 //        }
+        // TODO To be included when using API images
+        var theBitmap: Bitmap? = null
+        GlobalScope.launch {
+            try {
+                showProgress(toShow = true)
+//                imagename = "https://splicing-app.s3.us-east-2.amazonaws.com/demo-user-id/M7987_36_C_1.svg"
+//                imagename = "https://splicing-app.s3.us-east-2.amazonaws.com/demo-user-id/thumbnailImageUrl_.png"
+                theBitmap = imagename?.let { getBitmapFromSvgPngDrawable(it) }
+                withContext(Dispatchers.Main) {
+                    if (imagename != null) {
+                        mWorkspaceEditor?.addImage(
+                            theBitmap,
+                            viewModel.workspacedata,
+                            viewModel.scaleFactor.get(),
+                            showProjection,
+                            isDraggedPiece,
+                            this@WorkspaceTabFragment
+                        )
+                    }
+                }
+            } catch (e: Exception) {
+                e.printStackTrace()
+            }finally {
+                showProgress(toShow = false)
+            }
+        }
 
     }
 
Index: .idea/codeStyles/Project.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"ProjectCodeStyleConfiguration\">\r\n  <code_scheme name=\"Project\" version=\"173\">\r\n    <JetCodeStyleSettings>\r\n      <option name=\"PACKAGES_TO_USE_STAR_IMPORTS\">\r\n        <value>\r\n          <package name=\"java.util\" withSubpackages=\"false\" static=\"false\" />\r\n          <package name=\"kotlinx.android.synthetic\" withSubpackages=\"true\" static=\"false\" />\r\n          <package name=\"io.ktor\" withSubpackages=\"true\" static=\"false\" />\r\n        </value>\r\n      </option>\r\n      <option name=\"CODE_STYLE_DEFAULTS\" value=\"KOTLIN_OFFICIAL\" />\r\n    </JetCodeStyleSettings>\r\n    <MarkdownNavigatorCodeStyleSettings>\r\n      <option name=\"RIGHT_MARGIN\" value=\"72\" />\r\n    </MarkdownNavigatorCodeStyleSettings>\r\n    <codeStyleSettings language=\"XML\">\r\n      <indentOptions>\r\n        <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\r\n      </indentOptions>\r\n      <arrangement>\r\n        <rules>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>xmlns:android</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>xmlns:.*</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n              <order>BY_NAME</order>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>.*:id</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>.*:name</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>name</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>style</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>.*</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n              <order>BY_NAME</order>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>.*</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n              <order>ANDROID_ATTRIBUTE_ORDER</order>\r\n            </rule>\r\n          </section>\r\n          <section>\r\n            <rule>\r\n              <match>\r\n                <AND>\r\n                  <NAME>.*</NAME>\r\n                  <XML_ATTRIBUTE />\r\n                  <XML_NAMESPACE>.*</XML_NAMESPACE>\r\n                </AND>\r\n              </match>\r\n              <order>BY_NAME</order>\r\n            </rule>\r\n          </section>\r\n        </rules>\r\n      </arrangement>\r\n    </codeStyleSettings>\r\n    <codeStyleSettings language=\"kotlin\">\r\n      <option name=\"CODE_STYLE_DEFAULTS\" value=\"KOTLIN_OFFICIAL\" />\r\n    </codeStyleSettings>\r\n  </code_scheme>\r\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/codeStyles/Project.xml	(revision b1a9112ed1ce2865cf8c5448cc6c73d09b414055)
+++ .idea/codeStyles/Project.xml	(date 1629432437913)
@@ -3,9 +3,18 @@
     <JetCodeStyleSettings>
       <option name="PACKAGES_TO_USE_STAR_IMPORTS">
         <value>
-          <package name="java.util" withSubpackages="false" static="false" />
-          <package name="kotlinx.android.synthetic" withSubpackages="true" static="false" />
-          <package name="io.ktor" withSubpackages="true" static="false" />
+          <package name="java.util" alias="false" withSubpackages="false" />
+          <package name="kotlinx.android.synthetic" alias="false" withSubpackages="true" />
+          <package name="io.ktor" alias="false" withSubpackages="true" />
+        </value>
+      </option>
+      <option name="PACKAGES_IMPORT_LAYOUT">
+        <value>
+          <package name="" alias="false" withSubpackages="true" />
+          <package name="java" alias="false" withSubpackages="true" />
+          <package name="javax" alias="false" withSubpackages="true" />
+          <package name="kotlin" alias="false" withSubpackages="true" />
+          <package name="" alias="true" withSubpackages="true" />
         </value>
       </option>
       <option name="CODE_STYLE_DEFAULTS" value="KOTLIN_OFFICIAL" />
